{"Includes":["import (\n\t\"strconv\"\n\t\"strings\"\n\t\"unicode/utf8\"\n)"],"Defines":["const (\n\tmoov_io_ach_RecordLength                   = 94\n\tmoov_io_ach_SavingsCredit                  = 32\n\tmoov_io_ach_GLZeroDollarRemittanceCredit   = 44\n\tmoov_io_ach_LoanZeroDollarRemittanceCredit = 54\n\tmoov_io_ach_CreditSummary                  = 87\n)"],"TypeDefs":[],"Globals":["var ()"],"Structs":["type moov_io_ach_BatchControl struct {\n\t// ID is a client defined string used as a reference to this record.\n\n\t// ServiceClassCode ACH Mixed Debits and Credits '200'\n\t// ACH Credits Only '220'\n\t// ACH Debits Only '225'\n\t// Constants: MixedCreditsAnDebits (220), CReditsOnly 9220), DebitsOnly (225)\n\t// Same as 'ServiceClassCode' in BatchHeaderRecord\n\tServiceClassCode int `json:\"serviceClassCode\"`\n\t// EntryAddendaCount is a tally of each Entry Detail Record and each Addenda\n\t// Record processed, within either the batch or file as appropriate.\n\tEntryAddendaCount int `json:\"entryAddendaCount\"`\n\t// validate the Receiving DFI Identification in each Entry Detail Record is hashed\n\t// to provide a check against inadvertent alteration of data contents due\n\t// to hardware failure or program error\n\t//\n\t// In this context the Entry Hash is the sum of the corresponding fields in the\n\t// Entry Detail Records on the file.\n\tEntryHash int `json:\"entryHash\"`\n\t// TotalDebitEntryDollarAmount Contains accumulated Entry debit totals within the batch.\n\tTotalDebitEntryDollarAmount int `json:\"totalDebit\"`\n\t// TotalCreditEntryDollarAmount Contains accumulated Entry credit totals within the batch.\n\tTotalCreditEntryDollarAmount int `json:\"totalCredit\"`\n\t// CompanyIdentification is an alphanumeric code used to identify an Originator\n\t// The Company Identification Field must be included on all\n\t// prenotification records and on each entry initiated pursuant to such\n\t// prenotification. The Company ID may begin with the ANSI one-digit\n\t// Identification Code Designator (ICD), followed by the identification\n\t// number The ANSI Identification Numbers and related Identification Code\n\t// Designator (ICD) are:\n\t//\n\t// IRS Employer Identification Number (EIN) \"1\"\n\t// Data Universal Numbering Systems (DUNS) \"3\"\n\t// User Assigned Number \"9\"\n\tCompanyIdentification string `json:\"companyIdentification\"`\n\t// MessageAuthenticationCode the MAC is an eight character code derived from a special key used in\n\t// conjunction with the DES algorithm. The purpose of the MAC is to\n\t// validate the authenticity of ACH entries. The DES algorithm and key\n\t// message standards must be in accordance with standards adopted by the\n\t// American National Standards Institute. The remaining eleven characters\n\t// of this field are blank.\n\tMessageAuthenticationCode string `json:\"messageAuthentication,omitempty\"`\n\t// ODFIIdentification the routing number is used to identify the DFI originating entries within a given branch.\n\tODFIIdentification string `json:\"ODFIIdentification\"`\n\t// BatchNumber this number is assigned in ascending sequence to each batch by the ODFI\n\t// or its Sending Point in a given file of entries. Since the batch number\n\t// in the Batch Header Record and the Batch Control Record is the same,\n\t// the ascending sequence number should be assigned by batch and not by record.\n\tBatchNumber int `json:\"batchNumber\"`\n\t// validator is composed for data validation\n\n\t// converters is composed for ACH to golang Converters\n\tmoov_io_ach_converters\n\n\tvalidateOpts *moov_io_ach_ValidateOpts\n}","type moov_io_ach_converters struct{}","type moov_io_ach_ValidateOpts struct {\n\t// SkipAll will disable all validation checks of a File. It has no effect when set on records.\n\n\t// RequireABAOrigin can be set to enable routing number validation\n\t// over the ImmediateOrigin file header field.\n\n\t// BypassOriginValidation can be set to skip validation for the\n\t// ImmediateOrigin file header field.\n\t//\n\t// This also allows for custom TraceNumbers which aren't prefixed with\n\t// a routing number as required by the NACHA specification.\n\n\t// BypassDestinationValidation can be set to skip validation for the\n\t// ImmediateDestination file header field.\n\t//\n\t// This also allows for custom TraceNumbers which aren't prefixed with\n\t// a routing number as required by the NACHA specification.\n\n\t// CheckTransactionCode allows for custom validation of TransactionCode values\n\t//\n\t// Note: Functions cannot be serialized into/from JSON, so this check cannot be used from config files.\n\n\t// CustomTraceNumbers disables Nacha specified checks of TraceNumbers:\n\t// - Ascending order of trace numbers within batches\n\t// - Trace numbers beginning with their ODFI's routing number\n\t// - AddendaRecordIndicator is set correctly\n\n\t// AllowZeroBatches allows the file to have zero batches\n\n\t// AllowMissingFileHeader allows a file to be read without a FileHeader record.\n\n\t// AllowMissingFileControl allows a file to be read without a FileControl record.\n\n\t// BypassCompanyIdentificationMatch allows batches in which the Company Identification field\n\t// in the batch header and control do not match.\n\n\t// CustomReturnCodes can be set to skip validation for the Return Code field in an Addenda99\n\t// This allows for non-standard/deprecated return codes (e.g. R97)\n\n\t// UnequalServiceClassCode skips equality checks for the ServiceClassCode in each pair of BatchHeader\n\t// and BatchControl records.\n\n\t// AllowUnorderedBatchNumebrs allows a file to be read with unordered batch numbers.\n\n\t// AllowInvalidCheckDigit allows the CheckDigit field in EntryDetail to differ from\n\t// the expected calculation\n\n\t// UnequalAddendaCounts skips checking that Addenda Count fields match their expected and computed values.\n\n\t// PreserveSpaces keeps the spacing before and after values that normally have spaces trimmed during parsing.\n\tPreserveSpaces bool `json:\"preserveSpaces\"`\n\n\t// AllowInvalidAmounts will skip verifying the Amount is valid for the TransactionCode and entry type.\n\n}"],"Function Declarations":["","","",""],"Function Implementations":["func (c *moov_io_ach_converters) parseNumField(r string) (s int) {\n\ts, _ = strconv.Atoi(strings.TrimSpace(r))\n\treturn s\n}","func (c *moov_io_ach_converters) parseStringField(r string) (s string) {\n\ts = strings.TrimSpace(r)\n\treturn s\n}","func (c *moov_io_ach_converters) parseStringFieldWithOpts(r string, opts *moov_io_ach_ValidateOpts) string {\n\tif opts != nil \u0026\u0026 opts.PreserveSpaces {\n\t\treturn r\n\t} else {\n\t\treturn c.parseStringField(r)\n\t}\n}","func (bc *moov_io_ach_BatchControl) Parse(record string) {\n\tif utf8.RuneCountInString(record) != 94 {\n\t\treturn\n\t}\n\n\t// 1-1 Always \"8\"\n\t// 2-4 This is the same as the \"Service code\" field in previous Batch Header Record\n\tbc.ServiceClassCode = bc.parseNumField(record[1:4])\n\t// 5-10 Total number of Entry Detail Record in the batch\n\tbc.EntryAddendaCount = bc.parseNumField(record[4:10])\n\t// 11-20 Total of all positions 4-11 on each Entry Detail Record in the batch. This is essentially the sum of all the RDFI routing numbers in the batch.\n\t// If the sum exceeds 10 digits (because you have lots of Entry Detail Records), lop off the most significant digits of the sum until there are only 10\n\tbc.EntryHash = bc.parseNumField(record[10:20])\n\t// 21-32 Number of cents of debit entries within the batch\n\tbc.TotalDebitEntryDollarAmount = bc.parseNumField(record[20:32])\n\t// 33-44 Number of cents of credit entries within the batch\n\tbc.TotalCreditEntryDollarAmount = bc.parseNumField(record[32:44])\n\t// 45-54 This is the same as the \"Company identification\" field in previous Batch Header Record\n\tbc.CompanyIdentification = bc.parseStringFieldWithOpts(record[44:54], bc.validateOpts)\n\t// 55-73 Seems to always be blank\n\tbc.MessageAuthenticationCode = bc.parseStringFieldWithOpts(record[54:73], bc.validateOpts)\n\t// 74-79 Always blank (just fill with spaces)\n\t// 80-87 This is the same as the \"ODFI identification\" field in previous Batch Header Record\n\tbc.ODFIIdentification = bc.parseStringFieldWithOpts(record[79:87], bc.validateOpts)\n\t// 88-94 This is the same as the \"Batch number\" field in previous Batch Header Record\n\tbc.BatchNumber = bc.parseNumField(record[87:94])\n}"],"Enums":[]}

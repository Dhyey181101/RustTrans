{"Includes":["import (\n\t\"math\"\n)"],"Defines":[],"TypeDefs":[],"Globals":[],"Structs":["type geo_s1_Interval struct {\n\tLo, Hi float64\n}"],"Function Declarations":["","","","","",""],"Function Implementations":["func geo_s1_EmptyInterval() geo_s1_Interval { return geo_s1_Interval{math.Pi, -math.Pi} }","func (i geo_s1_Interval) IsEmpty() bool { return i.Lo == math.Pi \u0026\u0026 i.Hi == -math.Pi }","func (i geo_s1_Interval) IsInverted() bool { return i.Lo \u003e i.Hi }","func (i geo_s1_Interval) fastContains(p float64) bool {\n\tif i.IsInverted() {\n\t\treturn (p \u003e= i.Lo || p \u003c= i.Hi) \u0026\u0026 !i.IsEmpty()\n\t}\n\treturn p \u003e= i.Lo \u0026\u0026 p \u003c= i.Hi\n}","func (i geo_s1_Interval) Length() float64 {\n\tl := i.Hi - i.Lo\n\tif l \u003e= 0 {\n\t\treturn l\n\t}\n\tl += 2 * math.Pi\n\tif l \u003e 0 {\n\t\treturn l\n\t}\n\treturn -1\n}","func (i geo_s1_Interval) Intersection(oi geo_s1_Interval) geo_s1_Interval {\n\tif oi.IsEmpty() {\n\t\treturn geo_s1_EmptyInterval()\n\t}\n\tif i.fastContains(oi.Lo) {\n\t\tif i.fastContains(oi.Hi) {\n\t\t\t// Either oi ⊂ i, or i and oi intersect twice. Neither are empty.\n\t\t\t// In the first case we want to return i (which is shorter than oi).\n\t\t\t// In the second case one of them is inverted, and the smallest interval\n\t\t\t// that covers the two disjoint pieces is the shorter of i and oi.\n\t\t\t// We thus want to pick the shorter of i and oi in both cases.\n\t\t\tif oi.Length() \u003c i.Length() {\n\t\t\t\treturn oi\n\t\t\t}\n\t\t\treturn i\n\t\t}\n\t\treturn geo_s1_Interval{oi.Lo, i.Hi}\n\t}\n\tif i.fastContains(oi.Hi) {\n\t\treturn geo_s1_Interval{i.Lo, oi.Hi}\n\t}\n\n\t// Neither endpoint of oi is in i. Either i ⊂ oi, or i and oi are disjoint.\n\tif oi.fastContains(i.Lo) {\n\t\treturn i\n\t}\n\treturn geo_s1_EmptyInterval()\n}"],"Enums":[]}

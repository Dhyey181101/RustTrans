{"Includes":["import (\n\t\"math\"\n)"],"Defines":[],"TypeDefs":[],"Globals":["var (\n\tgeo_s1_dblEpsilon = 2.220446049e-16\n)"],"Structs":["type geo_s1_Interval struct {\n\tLo, Hi float64\n}"],"Function Declarations":["","","","","","",""],"Function Implementations":["func (i geo_s1_Interval) IsEmpty() bool { return i.Lo == math.Pi \u0026\u0026 i.Hi == -math.Pi }","func (i geo_s1_Interval) IsFull() bool { return i.Lo == -math.Pi \u0026\u0026 i.Hi == math.Pi }","func (i geo_s1_Interval) Length() float64 {\n\tl := i.Hi - i.Lo\n\tif l \u003e= 0 {\n\t\treturn l\n\t}\n\tl += 2 * math.Pi\n\tif l \u003e 0 {\n\t\treturn l\n\t}\n\treturn -1\n}","func geo_s1_IntervalFromEndpoints(lo, hi float64) geo_s1_Interval {\n\ti := geo_s1_Interval{lo, hi}\n\tif lo == -math.Pi \u0026\u0026 hi != math.Pi {\n\t\ti.Lo = math.Pi\n\t}\n\tif hi == -math.Pi \u0026\u0026 lo != math.Pi {\n\t\ti.Hi = math.Pi\n\t}\n\treturn i\n}","func geo_s1_FullInterval() geo_s1_Interval { return geo_s1_Interval{-math.Pi, math.Pi} }","func geo_s1_EmptyInterval() geo_s1_Interval { return geo_s1_Interval{math.Pi, -math.Pi} }","func (i geo_s1_Interval) Expanded(margin float64) geo_s1_Interval {\n\tif margin \u003e= 0 {\n\t\tif i.IsEmpty() {\n\t\t\treturn i\n\t\t}\n\t\t// Check whether this interval will be full after expansion, allowing\n\t\t// for a rounding error when computing each endpoint.\n\t\tif i.Length()+2*margin+2*geo_s1_dblEpsilon \u003e= 2*math.Pi {\n\t\t\treturn geo_s1_FullInterval()\n\t\t}\n\t} else {\n\t\tif i.IsFull() {\n\t\t\treturn i\n\t\t}\n\t\t// Check whether this interval will be empty after expansion, allowing\n\t\t// for a rounding error when computing each endpoint.\n\t\tif i.Length()+2*margin-2*geo_s1_dblEpsilon \u003c= 0 {\n\t\t\treturn geo_s1_EmptyInterval()\n\t\t}\n\t}\n\tresult := geo_s1_IntervalFromEndpoints(\n\t\tmath.Remainder(i.Lo-margin, 2*math.Pi),\n\t\tmath.Remainder(i.Hi+margin, 2*math.Pi),\n\t)\n\tif result.Lo \u003c= -math.Pi {\n\t\tresult.Lo = math.Pi\n\t}\n\treturn result\n}"],"Enums":[]}

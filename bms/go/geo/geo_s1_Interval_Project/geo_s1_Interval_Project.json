{"Includes":["import (\n\t\"math\"\n)"],"Defines":[],"TypeDefs":[],"Globals":[],"Structs":["type geo_s1_Interval struct {\n\tLo, Hi float64\n}"],"Function Declarations":["","","","",""],"Function Implementations":["func (i geo_s1_Interval) IsInverted() bool { return i.Lo \u003e i.Hi }","func (i geo_s1_Interval) IsEmpty() bool { return i.Lo == math.Pi \u0026\u0026 i.Hi == -math.Pi }","func (i geo_s1_Interval) fastContains(p float64) bool {\n\tif i.IsInverted() {\n\t\treturn (p \u003e= i.Lo || p \u003c= i.Hi) \u0026\u0026 !i.IsEmpty()\n\t}\n\treturn p \u003e= i.Lo \u0026\u0026 p \u003c= i.Hi\n}","func geo_s1_positiveDistance(a, b float64) float64 {\n\td := b - a\n\tif d \u003e= 0 {\n\t\treturn d\n\t}\n\treturn (b + math.Pi) - (a - math.Pi)\n}","func (i geo_s1_Interval) Project(p float64) float64 {\n\tif p == -math.Pi {\n\t\tp = math.Pi\n\t}\n\tif i.fastContains(p) {\n\t\treturn p\n\t}\n\t// Compute distance from p to each endpoint.\n\tdlo := geo_s1_positiveDistance(p, i.Lo)\n\tdhi := geo_s1_positiveDistance(i.Hi, p)\n\tif dlo \u003c dhi {\n\t\treturn i.Lo\n\t}\n\treturn i.Hi\n}"],"Enums":[]}

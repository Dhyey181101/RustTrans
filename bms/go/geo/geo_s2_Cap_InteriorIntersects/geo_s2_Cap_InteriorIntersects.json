{"Includes":["import (\n\t\"math\"\n)"],"Defines":["const (\n\tgeo_s1_StraightChordAngle = geo_s1_ChordAngle(4)\n\tgeo_s1_maxLength2         = 4.0\n)"],"TypeDefs":["type geo_s1_ChordAngle float64"],"Globals":[],"Structs":["type geo_s2_Cap struct {\n\tcenter geo_s2_Point\n\tradius geo_s1_ChordAngle\n}","type geo_s2_Point struct {\n\tgeo_r3_Vector\n}","type geo_r3_Vector struct {\n\tX, Y, Z float64\n}"],"Function Declarations":["","","","","","",""],"Function Implementations":["func (v geo_r3_Vector) Dot(ov geo_r3_Vector) float64 {\n\treturn float64(v.X*ov.X) + float64(v.Y*ov.Y) + float64(v.Z*ov.Z)\n}","func (v geo_r3_Vector) Norm2() float64 { return v.Dot(v) }","func (v geo_r3_Vector) Sub(ov geo_r3_Vector) geo_r3_Vector {\n\treturn geo_r3_Vector{v.X - ov.X, v.Y - ov.Y, v.Z - ov.Z}\n}","func (c geo_s1_ChordAngle) Add(other geo_s1_ChordAngle) geo_s1_ChordAngle {\n\t// Note that this method (and Sub) is much more efficient than converting\n\t// the ChordAngle to an Angle and adding those and converting back. It\n\t// requires only one square root plus a few additions and multiplications.\n\n\t// Optimization for the common case where b is an error tolerance\n\t// parameter that happens to be set to zero.\n\tif other == 0 {\n\t\treturn c\n\t}\n\n\t// Clamp the angle sum to at most 180 degrees.\n\tif c+other \u003e= geo_s1_maxLength2 {\n\t\treturn geo_s1_StraightChordAngle\n\t}\n\n\t// Let a and b be the (non-squared) chord lengths, and let c = a+b.\n\t// Let A, B, and C be the corresponding half-angles (a = 2*sin(A), etc).\n\t// Then the formula below can be derived from c = 2 * sin(A+B) and the\n\t// relationships   sin(A+B) = sin(A)*cos(B) + sin(B)*cos(A)\n\t//                 cos(X) = sqrt(1 - sin^2(X))\n\tx := float64(c * (1 - 0.25*other))\n\ty := float64(other * (1 - 0.25*c))\n\treturn geo_s1_ChordAngle(math.Min(geo_s1_maxLength2, x+y+2*math.Sqrt(x*y)))\n}","func geo_s2_ChordAngleBetweenPoints(x, y geo_s2_Point) geo_s1_ChordAngle {\n\treturn geo_s1_ChordAngle(math.Min(4.0, x.Sub(y.geo_r3_Vector).Norm2()))\n}","func (c geo_s2_Cap) IsEmpty() bool {\n\treturn c.radius \u003c 0\n}","func (c geo_s2_Cap) InteriorIntersects(other geo_s2_Cap) bool {\n\t// Make sure this cap has an interior and the other cap is non-empty.\n\tif c.radius \u003c= 0 || other.IsEmpty() {\n\t\treturn false\n\t}\n\n\treturn c.radius.Add(other.radius) \u003e geo_s2_ChordAngleBetweenPoints(c.center, other.center)\n}"],"Enums":[]}

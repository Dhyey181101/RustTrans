{"Includes":["import (\n\t\"math\"\n)"],"Defines":[],"TypeDefs":[],"Globals":["var (\n\tgeo_s1_epsilon = 1e-15\n)"],"Structs":["type geo_s1_Interval struct {\n\tLo, Hi float64\n}"],"Function Declarations":["","","",""],"Function Implementations":["func (i geo_s1_Interval) IsEmpty() bool { return i.Lo == math.Pi \u0026\u0026 i.Hi == -math.Pi }","func (i geo_s1_Interval) IsFull() bool { return i.Lo == -math.Pi \u0026\u0026 i.Hi == math.Pi }","func (i geo_s1_Interval) Length() float64 {\n\tl := i.Hi - i.Lo\n\tif l \u003e= 0 {\n\t\treturn l\n\t}\n\tl += 2 * math.Pi\n\tif l \u003e 0 {\n\t\treturn l\n\t}\n\treturn -1\n}","func (i geo_s1_Interval) ApproxEqual(other geo_s1_Interval) bool {\n\t// Full and empty intervals require special cases because the endpoints\n\t// are considered to be positioned arbitrarily.\n\tif i.IsEmpty() {\n\t\treturn other.Length() \u003c= 2*geo_s1_epsilon\n\t}\n\tif other.IsEmpty() {\n\t\treturn i.Length() \u003c= 2*geo_s1_epsilon\n\t}\n\tif i.IsFull() {\n\t\treturn other.Length() \u003e= 2*(math.Pi-geo_s1_epsilon)\n\t}\n\tif other.IsFull() {\n\t\treturn i.Length() \u003e= 2*(math.Pi-geo_s1_epsilon)\n\t}\n\n\t// The purpose of the last test below is to verify that moving the endpoints\n\t// does not invert the interval, e.g. [-1e20, 1e20] vs. [1e20, -1e20].\n\treturn (math.Abs(math.Remainder(other.Lo-i.Lo, 2*math.Pi)) \u003c= geo_s1_epsilon \u0026\u0026\n\t\tmath.Abs(math.Remainder(other.Hi-i.Hi, 2*math.Pi)) \u003c= geo_s1_epsilon \u0026\u0026\n\t\tmath.Abs(i.Length()-other.Length()) \u003c= 2*geo_s1_epsilon)\n\n}"],"Enums":[]}

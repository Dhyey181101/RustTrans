{"Includes":["import (\n\t\"math\"\n)"],"Defines":[],"TypeDefs":["type geo_s1_ChordAngle float64"],"Globals":[],"Structs":["type geo_s2_Cap struct {\n\tcenter geo_s2_Point\n\tradius geo_s1_ChordAngle\n}","type geo_s2_Point struct {\n\tgeo_r3_Vector\n}","type geo_r3_Vector struct {\n\tX, Y, Z float64\n}"],"Function Declarations":["","","","","",""],"Function Implementations":["func (v geo_r3_Vector) Dot(ov geo_r3_Vector) float64 {\n\treturn float64(v.X*ov.X) + float64(v.Y*ov.Y) + float64(v.Z*ov.Z)\n}","func (v geo_r3_Vector) Norm2() float64 { return v.Dot(v) }","func (v geo_r3_Vector) Sub(ov geo_r3_Vector) geo_r3_Vector {\n\treturn geo_r3_Vector{v.X - ov.X, v.Y - ov.Y, v.Z - ov.Z}\n}","func geo_s2_ChordAngleBetweenPoints(x, y geo_s2_Point) geo_s1_ChordAngle {\n\treturn geo_s1_ChordAngle(math.Min(4.0, x.Sub(y.geo_r3_Vector).Norm2()))\n}","func (c geo_s2_Cap) IsEmpty() bool {\n\treturn c.radius \u003c 0\n}","func (c geo_s2_Cap) AddPoint(p geo_s2_Point) geo_s2_Cap {\n\tif c.IsEmpty() {\n\t\tc.center = p\n\t\tc.radius = 0\n\t\treturn c\n\t}\n\n\t// After calling cap.AddPoint(p), cap.Contains(p) must be true. However\n\t// we don't need to do anything special to achieve this because Contains()\n\t// does exactly the same distance calculation that we do here.\n\tif newRad := geo_s2_ChordAngleBetweenPoints(c.center, p); newRad \u003e c.radius {\n\t\tc.radius = newRad\n\t}\n\treturn c\n}"],"Enums":[]}

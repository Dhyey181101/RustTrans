{"Includes":[],"Defines":["const (\n\tgeo_s2_MaxLevel = 30\n)"],"TypeDefs":["type geo_s2_CellID uint64"],"Globals":[],"Structs":[],"Function Declarations":["","","",""],"Function Implementations":["func (ci geo_s2_CellID) lsb() uint64 { return uint64(ci) \u0026 -uint64(ci) }","func geo_s2_lsbForLevel(level int) uint64 { return 1 \u003c\u003c uint64(2*(geo_s2_MaxLevel-level)) }","func (ci geo_s2_CellID) isFace() bool { return uint64(ci)\u0026(geo_s2_lsbForLevel(0)-1) == 0 }","func geo_s2_areSiblings(a, b, c, d geo_s2_CellID) bool {\n\t// A necessary (but not sufficient) condition is that the XOR of the\n\t// four cell IDs must be zero. This is also very fast to test.\n\tif (a ^ b ^ c) != d {\n\t\treturn false\n\t}\n\n\t// Now we do a slightly more expensive but exact test. First, compute a\n\t// mask that blocks out the two bits that encode the child position of\n\t// \"id\" with respect to its parent, then check that the other three\n\t// children all agree with \"mask\".\n\tmask := d.lsb() \u003c\u003c 1\n\tmask = ^(mask + (mask \u003c\u003c 1))\n\tidMasked := (uint64(d) \u0026 mask)\n\treturn ((uint64(a)\u0026mask) == idMasked \u0026\u0026\n\t\t(uint64(b)\u0026mask) == idMasked \u0026\u0026\n\t\t(uint64(c)\u0026mask) == idMasked \u0026\u0026\n\t\t!d.isFace())\n}"],"Enums":[]}

{"Includes":["import \"container/list\""],"Defines":["const ()"],"TypeDefs":[],"Globals":["var ()","var closest int","var maxDist float64"],"Structs":["type Point struct {\n\tX, Y float64\n}"],"Function Declarations":["","","","",""],"Function Implementations":["func (p Point) Distance2(r Point) float64 {\n\treturn (p.X-r.X)*(p.X-r.X) + (p.Y-r.Y)*(p.Y-r.Y)\n}","func isInsideTriangle(a, b, c, p Point) bool {\n\treturn (c.X-p.X)*(a.Y-p.Y)-(a.X-p.X)*(c.Y-p.Y) \u003e= 0 \u0026\u0026\n\t\t(a.X-p.X)*(b.Y-p.Y)-(b.X-p.X)*(a.Y-p.Y) \u003e= 0 \u0026\u0026\n\t\t(b.X-p.X)*(c.Y-p.Y)-(c.X-p.X)*(b.Y-p.Y) \u003e= 0\n}","func cyclic(i, n int) int {\n\treturn (i%n + n) % n\n}","func isReflex(a, b, c Point) bool {\n\treturn (b.X-a.X)*(c.Y-b.Y)-(c.X-b.X)*(b.Y-a.Y) \u003c 0\n}","func findClosest(m, k Point, pIndex int, outer []Point) int {\n\treflex := list.New()\n\tn := len(outer)\n\tfor i := 0; i \u003c n; i++ {\n\t\tnotInside := !isInsideTriangle(m, k, outer[pIndex], outer[i])\n\t\tprev, next := cyclic(i-1, n), cyclic(i+1, n)\n\t\tnotReflex := !isReflex(outer[prev], outer[i], outer[next])\n\t\tif notInside || notReflex {\n\t\t\tcontinue\n\t\t}\n\t\treflex.PushBack(i)\n\t}\n\tvar closest int\n\tvar maxDist float64\n\n\tfor r := reflex.Front(); r != nil; r = r.Next() {\n\t\ti := r.Value.(int)\n\t\tdist := outer[i].Distance2(outer[closest])\n\t\tif dist \u003e maxDist {\n\t\t\tclosest = i\n\t\t\tmaxDist = dist\n\t\t}\n\t}\n\treturn closest\n}"],"Enums":[]}

{"Includes":["import (\n\t\"errors\"\n)"],"Defines":["const ()"],"TypeDefs":[],"Globals":["var ()"],"Structs":["type Point struct {\n\tX, Y float64\n}"],"Function Declarations":["","",""],"Function Implementations":["func (p Point) Sub(r Point) Point {\n\treturn Point{p.X - r.X, p.Y - r.Y}\n}","func (p Point) Cross(r Point) float64 {\n\treturn p.X*r.Y - p.Y*r.X\n}","func findK(m Point, outer []Point) (k Point, k1, k2 int, err error) {\n\tfor i, j := len(outer)-1, 0; j \u003c len(outer); i, j = j, j+1 {\n\t\t// Skip edges that does not have their first point below `M` and the second\n\t\t// one above.\n\t\tif outer[i].Y \u003e m.Y || outer[j].Y \u003c m.Y {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Calculate simplified intersection of ray (1, 0) and [V_i, V_j] segment.\n\t\tv1 := m.Sub(outer[i])\n\t\tv2 := outer[j].Sub(outer[i])\n\n\t\tt1 := v2.Cross(v1) / v2.Y\n\t\tt2 := v1.Y / v2.Y\n\n\t\tif t1 \u003e= 0.0 \u0026\u0026 t2 \u003e= 0.0 \u0026\u0026 t2 \u003c= 1.0 {\n\t\t\t// If there is no current `k` candidate or this one is closer.\n\t\t\tif t1-m.X \u003c k.X {\n\t\t\t\tk = Point{X: t1 + m.X, Y: m.Y}\n\t\t\t\tk1, k2 = i, j\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\terr = errors.New(\"cannot calculate intersection, problematic data\")\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}"],"Enums":[]}

{"Includes":["import (\n\t\"container/list\"\n\t\"errors\"\n)"],"Defines":["const ()"],"TypeDefs":[],"Globals":["var ()","var pIndex int","var closest int","var maxDist float64"],"Structs":["type Point struct {\n\tX, Y float64\n}"],"Function Declarations":["","","","","","","","","",""],"Function Implementations":["func (p Point) Cross(r Point) float64 {\n\treturn p.X*r.Y - p.Y*r.X\n}","func (p Point) Sub(r Point) Point {\n\treturn Point{p.X - r.X, p.Y - r.Y}\n}","func findK(m Point, outer []Point) (k Point, k1, k2 int, err error) {\n\tfor i, j := len(outer)-1, 0; j \u003c len(outer); i, j = j, j+1 {\n\t\t// Skip edges that does not have their first point below `M` and the second\n\t\t// one above.\n\t\tif outer[i].Y \u003e m.Y || outer[j].Y \u003c m.Y {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Calculate simplified intersection of ray (1, 0) and [V_i, V_j] segment.\n\t\tv1 := m.Sub(outer[i])\n\t\tv2 := outer[j].Sub(outer[i])\n\n\t\tt1 := v2.Cross(v1) / v2.Y\n\t\tt2 := v1.Y / v2.Y\n\n\t\tif t1 \u003e= 0.0 \u0026\u0026 t2 \u003e= 0.0 \u0026\u0026 t2 \u003c= 1.0 {\n\t\t\t// If there is no current `k` candidate or this one is closer.\n\t\t\tif t1-m.X \u003c k.X {\n\t\t\t\tk = Point{X: t1 + m.X, Y: m.Y}\n\t\t\t\tk1, k2 = i, j\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\terr = errors.New(\"cannot calculate intersection, problematic data\")\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}","func cyclic(i, n int) int {\n\treturn (i%n + n) % n\n}","func (p Point) Distance2(r Point) float64 {\n\treturn (p.X-r.X)*(p.X-r.X) + (p.Y-r.Y)*(p.Y-r.Y)\n}","func isInsideTriangle(a, b, c, p Point) bool {\n\treturn (c.X-p.X)*(a.Y-p.Y)-(a.X-p.X)*(c.Y-p.Y) \u003e= 0 \u0026\u0026\n\t\t(a.X-p.X)*(b.Y-p.Y)-(b.X-p.X)*(a.Y-p.Y) \u003e= 0 \u0026\u0026\n\t\t(b.X-p.X)*(c.Y-p.Y)-(c.X-p.X)*(b.Y-p.Y) \u003e= 0\n}","func areAllOutside(m, k Point, pIndex int, outer []Point) bool {\n\tallOutside := true\n\tfor i := range outer {\n\t\t// We have to skip M, K and P vertices. Since M is from the inner\n\t\t// polygon and K was proved to not match any vertex, the only one to\n\t\t// check is pIndex\n\t\tif i == pIndex {\n\t\t\tcontinue\n\t\t}\n\n\t\tif isInsideTriangle(m, k, outer[pIndex], outer[i]) {\n\t\t\tallOutside = false\n\t\t}\n\t}\n\treturn allOutside\n}","func isReflex(a, b, c Point) bool {\n\treturn (b.X-a.X)*(c.Y-b.Y)-(c.X-b.X)*(b.Y-a.Y) \u003c 0\n}","func findClosest(m, k Point, pIndex int, outer []Point) int {\n\treflex := list.New()\n\tn := len(outer)\n\tfor i := 0; i \u003c n; i++ {\n\t\tnotInside := !isInsideTriangle(m, k, outer[pIndex], outer[i])\n\t\tprev, next := cyclic(i-1, n), cyclic(i+1, n)\n\t\tnotReflex := !isReflex(outer[prev], outer[i], outer[next])\n\t\tif notInside || notReflex {\n\t\t\tcontinue\n\t\t}\n\t\treflex.PushBack(i)\n\t}\n\tvar closest int\n\tvar maxDist float64\n\n\tfor r := reflex.Front(); r != nil; r = r.Next() {\n\t\ti := r.Value.(int)\n\t\tdist := outer[i].Distance2(outer[closest])\n\t\tif dist \u003e maxDist {\n\t\t\tclosest = i\n\t\t\tmaxDist = dist\n\t\t}\n\t}\n\treturn closest\n}","func combinePolygons(outer, inner []Point) ([]Point, error) {\n\txMax := 0.0\n\tmIndex := 0\n\tfor i := 0; i \u003c len(inner); i++ {\n\t\tif inner[i].X \u003e xMax {\n\t\t\txMax = inner[i].X\n\t\t\tmIndex = i\n\t\t}\n\t}\n\n\tm := inner[mIndex]\n\n\tvar pIndex int\n\tvisibleIndex := -1\n\n\tk, k1, k2, err := findK(m, outer)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// If `K` is vertex of the outer polygon, `M` and `K` are mutually visible.\n\tfor i := 0; i \u003c len(outer); i++ {\n\t\tif outer[i] == k {\n\t\t\tvisibleIndex = i\n\t\t}\n\t}\n\n\t// Otherwise, `K` is an interior point of the edge `[V_k_1, V_k_2]`. Find `P`\n\t// which is endpoint with greater x-value.\n\tif outer[k1].X \u003e outer[k2].X {\n\t\tpIndex = k1\n\t} else {\n\t\tpIndex = k2\n\t}\n\n\t// Check with all vertices of the outer polygon to be outside of the\n\t// triangle `[M, K, P]`. If it is true, `M` and `P` are mutually visible.\n\tallOutside := areAllOutside(m, k, pIndex, outer)\n\n\tif visibleIndex \u003c 0 \u0026\u0026 allOutside {\n\t\tvisibleIndex = pIndex\n\t}\n\n\t// Otherwise at least one reflex vertex lies in `[M, K, P]`. Search for the\n\t// array of reflex vertices `R` that minimizes the angle between `(1, 0)` and\n\t// line segment `[M, R]`. If there is exactly one vertex in `R` then they are\n\t// mutually visible. If there are multiple such vertices, pick the one closest\n\t// to `M`.\n\tif visibleIndex \u003c 0 {\n\t\tvisibleIndex = findClosest(m, k, pIndex, outer)\n\t}\n\n\tif visibleIndex \u003c 0 {\n\t\treturn nil, errors.New(\"could not find visible vertex\")\n\t}\n\n\tresult := make([]Point, 0, len(outer)+len(inner)+2)\n\tresult = append(result, outer[:visibleIndex+1]...)\n\tfor i := 0; i \u003c len(inner); i++ {\n\t\tresult = append(result, inner[cyclic(mIndex+i, len(inner))])\n\t}\n\tresult = append(result, inner[mIndex], outer[visibleIndex])\n\tresult = append(result, outer[visibleIndex+1:]...)\n\n\treturn result, nil\n}"],"Enums":[]}

{"Includes":["import (\n\t\"errors\"\n\t\"math\"\n)"],"Defines":["const ()"],"TypeDefs":[],"Globals":["var ()","var prev, next *Element"],"Structs":["type Point struct {\n\tX, Y float64\n}","type Element struct {\n\tPrev, Next *Element\n\tPoint      Point\n}"],"Function Declarations":["","","","","",""],"Function Implementations":["func isInsideTriangle(a, b, c, p Point) bool {\n\treturn (c.X-p.X)*(a.Y-p.Y)-(a.X-p.X)*(c.Y-p.Y) \u003e= 0 \u0026\u0026\n\t\t(a.X-p.X)*(b.Y-p.Y)-(b.X-p.X)*(a.Y-p.Y) \u003e= 0 \u0026\u0026\n\t\t(b.X-p.X)*(c.Y-p.Y)-(c.X-p.X)*(b.Y-p.Y) \u003e= 0\n}","func polygonArea(data []Point) float64 {\n\tarea := 0.0\n\tfor i, j := 0, len(data)-1; i \u003c len(data); i++ {\n\t\tarea += data[i].X*data[j].Y - data[i].Y*data[j].X\n\t\tj = i\n\t}\n\treturn math.Abs(area / 2)\n}","func (e *Element) Remove() {\n\te.Next.Prev = e.Prev\n\te.Prev.Next = e.Next\n}","func isReflex(a, b, c Point) bool {\n\treturn (b.X-a.X)*(c.Y-b.Y)-(c.X-b.X)*(b.Y-a.Y) \u003c 0\n}","func isEar(p *Element) bool {\n\ta, b, c := p.Prev.Point, p.Point, p.Next.Point\n\tif isReflex(a, b, c) {\n\t\treturn false\n\t}\n\n\tr := p.Next.Next\n\tfor r != p.Prev {\n\t\tinside := isInsideTriangle(a, b, c, r.Point)\n\t\treflex := isReflex(r.Prev.Point, r.Point, r.Next.Point)\n\t\tif inside \u0026\u0026 reflex {\n\t\t\treturn false\n\t\t}\n\t\tr = r.Next\n\t}\n\treturn true\n}","func Polygon(points []Point) ([]float64, error) {\n\tn := len(points)\n\n\tif n \u003c 3 {\n\t\treturn nil, errors.New(\"cannot triangulate less than three points\")\n\t}\n\n\t// Allocate memory for all needed elements and initialize them by hand.\n\telements := make([]Element, n)\n\telements[0].Prev, elements[0].Next = \u0026elements[n-1], \u0026elements[1]\n\telements[0].Point = points[0]\n\tfor i := 1; i \u003c n-1; i++ {\n\t\telements[i].Prev, elements[i].Next = \u0026elements[i-1], \u0026elements[i+1]\n\t\telements[i].Point = points[i]\n\t}\n\telements[n-1].Prev, elements[n-1].Next = \u0026elements[n-2], \u0026elements[0]\n\telements[n-1].Point = points[n-1]\n\n\tear := \u0026elements[0]\n\n\t// Any triangulation of simple polygon has n-2 triangles. Triangle has 3\n\t// two-dimensional coordinates.\n\ti, t := 0, make([]float64, (n-2)*6)\n\n\tstop := ear\n\tvar prev, next *Element\n\n\tfor ear.Prev != ear.Next {\n\t\tprev = ear.Prev\n\t\tnext = ear.Next\n\n\t\tif isEar(ear) {\n\t\t\tif polygonArea([]Point{prev.Point, ear.Point, next.Point}) \u003e 0 {\n\t\t\t\tt[i+0], t[i+1] = prev.Point.X, prev.Point.Y\n\t\t\t\tt[i+2], t[i+3] = ear.Point.X, ear.Point.Y\n\t\t\t\tt[i+4], t[i+5] = next.Point.X, next.Point.Y\n\t\t\t\ti += 6\n\t\t\t}\n\n\t\t\tear.Remove()\n\t\t\tear = ear.Next\n\t\t\tstop = stop.Next\n\t\t\tcontinue\n\t\t}\n\n\t\tear = next\n\n\t\tif ear == stop {\n\t\t\treturn []float64{}, errors.New(\"oops\")\n\t\t}\n\t}\n\n\t// Return array slice of size consisting only of the elements actually took by\n\t// the triangulation (sometimes the number of triangles is lower than n-2 and\n\t// zeroes are filling the rest of the array).\n\treturn t[0:i], nil\n}"],"Enums":[]}

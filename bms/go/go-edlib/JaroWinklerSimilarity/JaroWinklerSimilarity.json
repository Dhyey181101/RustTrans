{"Includes":["import (\n)"],"Defines":["const (\n)"],"TypeDefs":[],"Globals":["var (\n)","var prefix int","var match int","var t float32","var p int"],"Structs":[],"Function Declarations":["","","","",""],"Function Implementations":["func Min(a int, b int) int {\n\tif b \u003c a {\n\t\treturn b\n\t}\n\treturn a\n}","func Equal(a, b []rune) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i, v := range a {\n\t\tif v != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","func Max(a int, b int) int {\n\tif b \u003e a {\n\t\treturn b\n\t}\n\treturn a\n}","func JaroSimilarity(str1, str2 string) float32 {\n\t// Convert string parameters to rune arrays to be compatible with non-ASCII\n\truneStr1 := []rune(str1)\n\truneStr2 := []rune(str2)\n\n\t// Get and store length of these strings\n\truneStr1len := len(runeStr1)\n\truneStr2len := len(runeStr2)\n\tif runeStr1len == 0 || runeStr2len == 0 {\n\t\treturn 0.0\n\t} else if Equal(runeStr1, runeStr2) {\n\t\treturn 1.0\n\t}\n\n\tvar match int\n\t// Maximum matching distance allowed\n\tmaxDist := Max(runeStr1len, runeStr2len)/2 - 1\n\t// Correspondence tables (1 for matching and 0 if it's not the case)\n\tstr1Table := make([]int, runeStr1len)\n\tstr2Table := make([]int, runeStr2len)\n\n\t// Check for matching characters in both strings\n\tfor i := 0; i \u003c runeStr1len; i++ {\n\t\tfor j := Max(0, i-maxDist); j \u003c Min(runeStr2len, i+maxDist+1); j++ {\n\t\t\tif runeStr1[i] == runeStr2[j] \u0026\u0026 str2Table[j] == 0 {\n\t\t\t\tstr1Table[i] = 1\n\t\t\t\tstr2Table[j] = 1\n\t\t\t\tmatch++\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tif match == 0 {\n\t\treturn 0.0\n\t}\n\n\tvar t float32\n\tvar p int\n\t// Check for possible translations\n\tfor i := 0; i \u003c runeStr1len; i++ {\n\t\tif str1Table[i] == 1 {\n\t\t\tfor str2Table[p] == 0 {\n\t\t\t\tp++\n\t\t\t}\n\t\t\tif runeStr1[i] != runeStr2[p] {\n\t\t\t\tt++\n\t\t\t}\n\t\t\tp++\n\t\t}\n\t}\n\tt /= 2\n\n\treturn (float32(match)/float32(runeStr1len) +\n\t\tfloat32(match)/float32(runeStr2len) +\n\t\t(float32(match)-t)/float32(match)) / 3.0\n}","func JaroWinklerSimilarity(str1, str2 string) float32 {\n\t// Get Jaro similarity index between str1 and str2\n\tjaroSim := JaroSimilarity(str1, str2)\n\n\tif jaroSim != 0.0 \u0026\u0026 jaroSim != 1.0 {\n\t\t// Convert string parameters to rune arrays to be compatible with non-ASCII\n\t\truneStr1 := []rune(str1)\n\t\truneStr2 := []rune(str2)\n\n\t\t// Get and store length of these strings\n\t\truneStr1len := len(runeStr1)\n\t\truneStr2len := len(runeStr2)\n\n\t\tvar prefix int\n\n\t\t// Find length of the common prefix\n\t\tfor i := 0; i \u003c Min(runeStr1len, runeStr2len); i++ {\n\t\t\tif runeStr1[i] == runeStr2[i] {\n\t\t\t\tprefix++\n\t\t\t} else {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// Normalized prefix count with Winkler's constraint\n\t\t// (prefix length must be inferior or equal to 4)\n\t\tprefix = Min(prefix, 4)\n\n\t\t// Return calculated Jaro-Winkler similarity index\n\t\treturn jaroSim + 0.1*float32(prefix)*(1-jaroSim)\n\t}\n\n\treturn jaroSim\n}"],"Enums":[]}

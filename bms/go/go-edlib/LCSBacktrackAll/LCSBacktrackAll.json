{"Includes":["import (\n\t\"errors\"\n)"],"Defines":["const ()"],"TypeDefs":["type StringHashMap map[string]struct{}"],"Globals":["var ()","var index int"],"Structs":[],"Function Declarations":["","","","","","",""],"Function Implementations":["func Max(a int, b int) int {\n\tif b \u003e a {\n\t\treturn b\n\t}\n\treturn a\n}","func lcsProcess(runeStr1, runeStr2 []rune) [][]int {\n\t// 2D Array that will contain str1 and str2 LCS\n\tlcsMatrix := make([][]int, len(runeStr1)+1)\n\tfor i := 0; i \u003c= len(runeStr1); i++ {\n\t\tlcsMatrix[i] = make([]int, len(runeStr2)+1)\n\t\tfor j := 0; j \u003c= len(runeStr2); j++ {\n\t\t\tlcsMatrix[i][j] = 0\n\t\t}\n\t}\n\n\tfor i := 1; i \u003c= len(runeStr1); i++ {\n\t\tfor j := 1; j \u003c= len(runeStr2); j++ {\n\t\t\tif runeStr1[i-1] == runeStr2[j-1] {\n\t\t\t\tlcsMatrix[i][j] = lcsMatrix[i-1][j-1] + 1\n\t\t\t} else {\n\t\t\t\tlcsMatrix[i][j] = Max(lcsMatrix[i][j-1], lcsMatrix[i-1][j])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn lcsMatrix\n}","func (m StringHashMap) AddAll(srcMap StringHashMap) {\n\tfor key := range srcMap {\n\t\tm[key] = struct{}{}\n\t}\n}","func processLCSBacktrackAll(str1, str2 string, lcsMatrix [][]int, m, n int) StringHashMap {\n\t// Convert strings to rune array to handle no-ASCII characters\n\truneStr1 := []rune(str1)\n\truneStr2 := []rune(str2)\n\n\t// Map containing all commons substrings (Hash set builded from map)\n\tsubstrings := make(StringHashMap)\n\n\tif m == 0 || n == 0 {\n\t\tsubstrings[\"\"] = struct{}{}\n\t} else if runeStr1[m-1] == runeStr2[n-1] {\n\t\tfor key := range processLCSBacktrackAll(str1, str2, lcsMatrix, m-1, n-1) {\n\t\t\tsubstrings[key+string(runeStr1[m-1])] = struct{}{}\n\t\t}\n\t} else {\n\t\tif lcsMatrix[m-1][n] \u003e= lcsMatrix[m][n-1] {\n\t\t\tsubstrings.AddAll(processLCSBacktrackAll(str1, str2, lcsMatrix, m-1, n))\n\t\t}\n\t\tif lcsMatrix[m][n-1] \u003e= lcsMatrix[m-1][n] {\n\t\t\tsubstrings.AddAll(processLCSBacktrackAll(str1, str2, lcsMatrix, m, n-1))\n\t\t}\n\t}\n\n\treturn substrings\n}","func (m StringHashMap) ToArray() []string {\n\tvar index int\n\tarr := make([]string, 0, len(m))\n\tfor key := range m {\n\t\tarr = append(arr, key)\n\t\tindex++\n\t}\n\n\treturn arr\n}","func Equal(a, b []rune) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i, v := range a {\n\t\tif v != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","func LCSBacktrackAll(str1, str2 string) ([]string, error) {\n\truneStr1 := []rune(str1)\n\truneStr2 := []rune(str2)\n\n\tif len(runeStr1) == 0 || len(runeStr2) == 0 {\n\t\treturn nil, errors.New(\"Can't process and backtrack any LCS with empty string\")\n\t} else if Equal(runeStr1, runeStr2) {\n\t\treturn []string{str1}, nil\n\t}\n\n\treturn processLCSBacktrackAll(str1, str2, lcsProcess(runeStr1, runeStr2), len(runeStr1), len(runeStr2)).ToArray(), nil\n}"],"Enums":[]}

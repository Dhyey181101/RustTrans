{"Includes":["import (\n)"],"Defines":["const (\n)"],"TypeDefs":[],"Globals":["var (\n)","var count int"],"Structs":[],"Function Declarations":["","",""],"Function Implementations":["func Equal(a, b []rune) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i, v := range a {\n\t\tif v != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","func Min(a int, b int) int {\n\tif b \u003c a {\n\t\treturn b\n\t}\n\treturn a\n}","func OSADamerauLevenshteinDistance(str1, str2 string) int {\n\t// Convert string parameters to rune arrays to be compatible with non-ASCII\n\truneStr1 := []rune(str1)\n\truneStr2 := []rune(str2)\n\n\t// Get and store length of these strings\n\truneStr1len := len(runeStr1)\n\truneStr2len := len(runeStr2)\n\tif runeStr1len == 0 {\n\t\treturn runeStr2len\n\t} else if runeStr2len == 0 {\n\t\treturn runeStr1len\n\t} else if Equal(runeStr1, runeStr2) {\n\t\treturn 0\n\t} else if runeStr1len \u003c runeStr2len {\n\t\treturn OSADamerauLevenshteinDistance(str2, str1)\n\t}\n\n\t// 2D Array\n\trow := Min(runeStr1len+1, 3)\n\tmatrix := make([][]int, row)\n\tfor i := 0; i \u003c row; i++ {\n\t\tmatrix[i] = make([]int, runeStr2len+1)\n\t\tmatrix[i][0] = i\n\t}\n\n\tfor j := 0; j \u003c= runeStr2len; j++ {\n\t\tmatrix[0][j] = j\n\t}\n\n\tvar count int\n\tfor i := 1; i \u003c= runeStr1len; i++ {\n\t\tmatrix[i%3][0] = i\n\t\tfor j := 1; j \u003c= runeStr2len; j++ {\n\t\t\tif runeStr1[i-1] == runeStr2[j-1] {\n\t\t\t\tcount = 0\n\t\t\t} else {\n\t\t\t\tcount = 1\n\t\t\t}\n\n\t\t\tmatrix[i%3][j] = Min(Min(matrix[(i-1)%3][j]+1, matrix[i%3][j-1]+1),\n\t\t\t\tmatrix[(i-1)%3][j-1]+count) // insertion, deletion, substitution\n\t\t\tif i \u003e 1 \u0026\u0026 j \u003e 1 \u0026\u0026 runeStr1[i-1] == runeStr2[j-2] \u0026\u0026 runeStr1[i-2] == runeStr2[j-1] {\n\t\t\t\tmatrix[i%3][j] = Min(matrix[i%3][j], matrix[(i-2)%3][j-2]+1) // translation\n\t\t\t}\n\t\t}\n\t}\n\treturn matrix[runeStr1len%3][runeStr2len]\n}"],"Enums":[]}

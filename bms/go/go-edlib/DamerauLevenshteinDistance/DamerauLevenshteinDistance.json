{"Includes":["import (\n)"],"Defines":["const (\n)"],"TypeDefs":[],"Globals":["var (\n)","var cost int"],"Structs":[],"Function Declarations":["","",""],"Function Implementations":["func Min(a int, b int) int {\n\tif b \u003c a {\n\t\treturn b\n\t}\n\treturn a\n}","func Equal(a, b []rune) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i, v := range a {\n\t\tif v != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","func DamerauLevenshteinDistance(str1, str2 string) int {\n\t// Convert string parameters to rune arrays to be compatible with non-ASCII\n\truneStr1 := []rune(str1)\n\truneStr2 := []rune(str2)\n\n\t// Get and store length of these strings\n\truneStr1len := len(runeStr1)\n\truneStr2len := len(runeStr2)\n\tif runeStr1len == 0 {\n\t\treturn runeStr2len\n\t} else if runeStr2len == 0 {\n\t\treturn runeStr1len\n\t} else if Equal(runeStr1, runeStr2) {\n\t\treturn 0\n\t}\n\n\t// Create alphabet based on input strings\n\tda := make(map[rune]int)\n\tfor i := 0; i \u003c runeStr1len; i++ {\n\t\tda[runeStr1[i]] = 0\n\t}\n\tfor i := 0; i \u003c runeStr2len; i++ {\n\t\tda[runeStr2[i]] = 0\n\t}\n\n\t// 2D Array for distance matrix : matrix[0..str1.length+2][0..s2.length+2]\n\tmatrix := make([][]int, runeStr1len+2)\n\tfor i := 0; i \u003c= runeStr1len+1; i++ {\n\t\tmatrix[i] = make([]int, runeStr2len+2)\n\t\tfor j := 0; j \u003c= runeStr2len+1; j++ {\n\t\t\tmatrix[i][j] = 0\n\t\t}\n\t}\n\n\t// Maximum possible distance\n\tmaxDist := runeStr1len + runeStr2len\n\n\t// Initialize matrix\n\tmatrix[0][0] = maxDist\n\tfor i := 0; i \u003c= runeStr1len; i++ {\n\t\tmatrix[i+1][0] = maxDist\n\t\tmatrix[i+1][1] = i\n\t}\n\tfor i := 0; i \u003c= runeStr2len; i++ {\n\t\tmatrix[0][i+1] = maxDist\n\t\tmatrix[1][i+1] = i\n\t}\n\n\t// Process edit distance\n\tvar cost int\n\tfor i := 1; i \u003c= runeStr1len; i++ {\n\t\tdb := 0\n\t\tfor j := 1; j \u003c= runeStr2len; j++ {\n\t\t\ti1 := da[runeStr2[j-1]]\n\t\t\tj1 := db\n\t\t\tif runeStr1[i-1] == runeStr2[j-1] {\n\t\t\t\tcost = 0\n\t\t\t\tdb = j\n\t\t\t} else {\n\t\t\t\tcost = 1\n\t\t\t}\n\n\t\t\tmatrix[i+1][j+1] = Min(\n\t\t\t\tMin(\n\t\t\t\t\tmatrix[i+1][j]+1,  // Addition\n\t\t\t\t\tmatrix[i][j+1]+1), // Deletion\n\t\t\t\tMin(\n\t\t\t\t\tmatrix[i][j]+cost, // Substitution\n\t\t\t\t\tmatrix[i1][j1]+(i-i1-1)+1+(j-j1-1))) // Transposition\n\t\t}\n\n\t\tda[runeStr1[i-1]] = i\n\t}\n\n\treturn matrix[runeStr1len+1][runeStr2len+1]\n}"],"Enums":[]}

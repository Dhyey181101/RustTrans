{"Includes":["import (\n\t\"errors\"\n\t\"math\"\n\t\"strings\"\n)"],"Defines":["const (\n\tLevenshtein Algorithm = iota\n\tDamerauLevenshtein\n\tOSADamerauLevenshtein\n\tLcs\n\tHamming\n\tJaro\n\tJaroWinkler\n\tCosine\n\tJaccard\n\tSorensenDice\n\tQgram\n)"],"TypeDefs":["type Algorithm uint8"],"Globals":["var ()","var higherMatchPercent float32","var tmpStr string","var i int","var cost int","var count int","var counter int","var match int","var t float32","var p int","var prefix int","var splittedStr1, splittedStr2 []string","var l1, l2 []int","var cosineSim float32","var out []string","var res int","var splittedStr1, splittedStr2 []string"],"Structs":[],"Function Declarations":["","","","","","","","","","","","","","","","","","","","","","","","",""],"Function Implementations":["func Equal(a, b []rune) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i, v := range a {\n\t\tif v != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","func find(slice [][]rune, val []rune) int {\n\tfor i, item := range slice {\n\t\tif Equal(item, val) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}","func sum(arr []int) int {\n\tvar res int\n\tfor _, v := range arr {\n\t\tres += v\n\t}\n\treturn res\n}","func ShingleSlice(s string, k int) []string {\n\tvar out []string\n\tm := make(map[string]int)\n\tif s != \"\" \u0026\u0026 k != 0 {\n\t\truneS := []rune(s)\n\t\tfor i := 0; i \u003c len(runeS)-k+1; i++ {\n\t\t\tm[string(runeS[i:i+k])]++\n\t\t}\n\t\tfor k := range m {\n\t\t\tout = append(out, k)\n\t\t}\n\t}\n\treturn out\n}","func union(a, b []string) [][]rune {\n\tm := make(map[string]bool)\n\tfor _, item := range a {\n\t\tm[item] = true\n\t}\n\tfor _, item := range b {\n\t\tif _, ok := m[item]; !ok {\n\t\t\ta = append(a, item)\n\t\t}\n\t}\n\n\t// Convert a to rune matrix (with x -\u003e words and y -\u003e characters)\n\tout := make([][]rune, len(a))\n\tfor i, word := range a {\n\t\tout[i] = []rune(word)\n\t}\n\treturn out\n}","func CosineSimilarity(str1, str2 string, splitLength int) float32 {\n\tif str1 == \"\" || str2 == \"\" {\n\t\treturn 0\n\t}\n\n\t// Split string before rune conversion for cosine calculation\n\t// If splitLength == 0 then split on whitespaces\n\t// Else use shingle algorithm\n\tvar splittedStr1, splittedStr2 []string\n\tif splitLength == 0 {\n\t\tsplittedStr1 = strings.Split(str1, \" \")\n\t\tsplittedStr2 = strings.Split(str2, \" \")\n\t} else {\n\t\tsplittedStr1 = ShingleSlice(str1, splitLength)\n\t\tsplittedStr2 = ShingleSlice(str2, splitLength)\n\t}\n\n\t// Conversion of plitted string into rune array\n\truneStr1 := make([][]rune, len(splittedStr1))\n\tfor i, str := range splittedStr1 {\n\t\truneStr1[i] = []rune(str)\n\t}\n\truneStr2 := make([][]rune, len(splittedStr2))\n\tfor i, str := range splittedStr2 {\n\t\truneStr2[i] = []rune(str)\n\t}\n\n\tvar l1, l2 []int\n\t// Create union keywords slice between input strings\n\tunionStr := union(splittedStr1, splittedStr2)\n\tfor _, word := range unionStr {\n\t\tfw := find(runeStr1, word)\n\t\tif fw != -1 {\n\t\t\tl1 = append(l1, 1)\n\t\t} else {\n\t\t\tl1 = append(l1, 0)\n\t\t}\n\n\t\tfw = find(runeStr2, word)\n\t\tif fw != -1 {\n\t\t\tl2 = append(l2, 1)\n\t\t} else {\n\t\t\tl2 = append(l2, 0)\n\t\t}\n\t}\n\n\t// Compute cosine algorithm\n\tvar cosineSim float32\n\tfor i := 0; i \u003c len(unionStr); i++ {\n\t\tcosineSim += float32(l1[i] * l2[i])\n\t}\n\n\treturn cosineSim / float32(math.Sqrt(float64(sum(l1)*sum(l2))))\n}","func Min(a int, b int) int {\n\tif b \u003c a {\n\t\treturn b\n\t}\n\treturn a\n}","func LevenshteinDistance(str1, str2 string) int {\n\t// Convert string parameters to rune arrays to be compatible with non-ASCII\n\truneStr1 := []rune(str1)\n\truneStr2 := []rune(str2)\n\n\t// Get and store length of these strings\n\truneStr1len := len(runeStr1)\n\truneStr2len := len(runeStr2)\n\tif runeStr1len == 0 {\n\t\treturn runeStr2len\n\t} else if runeStr2len == 0 {\n\t\treturn runeStr1len\n\t} else if Equal(runeStr1, runeStr2) {\n\t\treturn 0\n\t}\n\n\tcolumn := make([]int, runeStr1len+1)\n\n\tfor y := 1; y \u003c= runeStr1len; y++ {\n\t\tcolumn[y] = y\n\t}\n\tfor x := 1; x \u003c= runeStr2len; x++ {\n\t\tcolumn[0] = x\n\t\tlastkey := x - 1\n\t\tfor y := 1; y \u003c= runeStr1len; y++ {\n\t\t\toldkey := column[y]\n\t\t\tvar i int\n\t\t\tif runeStr1[y-1] != runeStr2[x-1] {\n\t\t\t\ti = 1\n\t\t\t}\n\t\t\tcolumn[y] = Min(\n\t\t\t\tMin(column[y]+1, // insert\n\t\t\t\t\tcolumn[y-1]+1), // delete\n\t\t\t\tlastkey+i) // substitution\n\t\t\tlastkey = oldkey\n\t\t}\n\t}\n\n\treturn column[runeStr1len]\n}","func JaccardSimilarity(str1, str2 string, splitLength int) float32 {\n\tif str1 == \"\" || str2 == \"\" {\n\t\treturn 0\n\t}\n\n\t// Split string before rune conversion for jaccard calculation\n\t// If splitLength == 0 then split on whitespaces\n\t// Else use shingle algorithm\n\tvar splittedStr1, splittedStr2 []string\n\tif splitLength == 0 {\n\t\tsplittedStr1 = strings.Split(str1, \" \")\n\t\tsplittedStr2 = strings.Split(str2, \" \")\n\t} else {\n\t\tsplittedStr1 = ShingleSlice(str1, splitLength)\n\t\tsplittedStr2 = ShingleSlice(str2, splitLength)\n\t}\n\n\t// Conversion of splitted string into rune array\n\truneStr1 := make([][]rune, len(splittedStr1))\n\tfor i, str := range splittedStr1 {\n\t\truneStr1[i] = []rune(str)\n\t}\n\truneStr2 := make([][]rune, len(splittedStr2))\n\tfor i, str := range splittedStr2 {\n\t\truneStr2[i] = []rune(str)\n\t}\n\n\t// Create union keywords slice between input strings\n\tunionStr := union(splittedStr1, splittedStr2)\n\tjacc := float32(len(runeStr1) + len(runeStr2) - len(unionStr))\n\n\treturn jacc / float32(len(unionStr))\n}","func Max(a int, b int) int {\n\tif b \u003e a {\n\t\treturn b\n\t}\n\treturn a\n}","func lcsProcess(runeStr1, runeStr2 []rune) [][]int {\n\t// 2D Array that will contain str1 and str2 LCS\n\tlcsMatrix := make([][]int, len(runeStr1)+1)\n\tfor i := 0; i \u003c= len(runeStr1); i++ {\n\t\tlcsMatrix[i] = make([]int, len(runeStr2)+1)\n\t\tfor j := 0; j \u003c= len(runeStr2); j++ {\n\t\t\tlcsMatrix[i][j] = 0\n\t\t}\n\t}\n\n\tfor i := 1; i \u003c= len(runeStr1); i++ {\n\t\tfor j := 1; j \u003c= len(runeStr2); j++ {\n\t\t\tif runeStr1[i-1] == runeStr2[j-1] {\n\t\t\t\tlcsMatrix[i][j] = lcsMatrix[i-1][j-1] + 1\n\t\t\t} else {\n\t\t\t\tlcsMatrix[i][j] = Max(lcsMatrix[i][j-1], lcsMatrix[i-1][j])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn lcsMatrix\n}","func LCS(str1, str2 string) int {\n\t// Convert strings to rune array to handle no-ASCII characters\n\truneStr1 := []rune(str1)\n\truneStr2 := []rune(str2)\n\n\tif len(runeStr1) == 0 || len(runeStr2) == 0 {\n\t\treturn 0\n\t} else if Equal(runeStr1, runeStr2) {\n\t\treturn len(runeStr1)\n\t}\n\n\tlcsMatrix := lcsProcess(runeStr1, runeStr2)\n\treturn lcsMatrix[len(runeStr1)][len(runeStr2)]\n}","func LCSEditDistance(str1, str2 string) int {\n\tif len(str1) == 0 {\n\t\treturn len(str2)\n\t} else if len(str2) == 0 {\n\t\treturn len(str1)\n\t} else if str1 == str2 {\n\t\treturn 0\n\t}\n\n\tlcs := LCS(str1, str2)\n\treturn (len([]rune(str1)) - lcs) + (len([]rune(str2)) - lcs)\n}","func JaroSimilarity(str1, str2 string) float32 {\n\t// Convert string parameters to rune arrays to be compatible with non-ASCII\n\truneStr1 := []rune(str1)\n\truneStr2 := []rune(str2)\n\n\t// Get and store length of these strings\n\truneStr1len := len(runeStr1)\n\truneStr2len := len(runeStr2)\n\tif runeStr1len == 0 || runeStr2len == 0 {\n\t\treturn 0.0\n\t} else if Equal(runeStr1, runeStr2) {\n\t\treturn 1.0\n\t}\n\n\tvar match int\n\t// Maximum matching distance allowed\n\tmaxDist := Max(runeStr1len, runeStr2len)/2 - 1\n\t// Correspondence tables (1 for matching and 0 if it's not the case)\n\tstr1Table := make([]int, runeStr1len)\n\tstr2Table := make([]int, runeStr2len)\n\n\t// Check for matching characters in both strings\n\tfor i := 0; i \u003c runeStr1len; i++ {\n\t\tfor j := Max(0, i-maxDist); j \u003c Min(runeStr2len, i+maxDist+1); j++ {\n\t\t\tif runeStr1[i] == runeStr2[j] \u0026\u0026 str2Table[j] == 0 {\n\t\t\t\tstr1Table[i] = 1\n\t\t\t\tstr2Table[j] = 1\n\t\t\t\tmatch++\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tif match == 0 {\n\t\treturn 0.0\n\t}\n\n\tvar t float32\n\tvar p int\n\t// Check for possible translations\n\tfor i := 0; i \u003c runeStr1len; i++ {\n\t\tif str1Table[i] == 1 {\n\t\t\tfor str2Table[p] == 0 {\n\t\t\t\tp++\n\t\t\t}\n\t\t\tif runeStr1[i] != runeStr2[p] {\n\t\t\t\tt++\n\t\t\t}\n\t\t\tp++\n\t\t}\n\t}\n\tt /= 2\n\n\treturn (float32(match)/float32(runeStr1len) +\n\t\tfloat32(match)/float32(runeStr2len) +\n\t\t(float32(match)-t)/float32(match)) / 3.0\n}","func JaroWinklerSimilarity(str1, str2 string) float32 {\n\t// Get Jaro similarity index between str1 and str2\n\tjaroSim := JaroSimilarity(str1, str2)\n\n\tif jaroSim != 0.0 \u0026\u0026 jaroSim != 1.0 {\n\t\t// Convert string parameters to rune arrays to be compatible with non-ASCII\n\t\truneStr1 := []rune(str1)\n\t\truneStr2 := []rune(str2)\n\n\t\t// Get and store length of these strings\n\t\truneStr1len := len(runeStr1)\n\t\truneStr2len := len(runeStr2)\n\n\t\tvar prefix int\n\n\t\t// Find length of the common prefix\n\t\tfor i := 0; i \u003c Min(runeStr1len, runeStr2len); i++ {\n\t\t\tif runeStr1[i] == runeStr2[i] {\n\t\t\t\tprefix++\n\t\t\t} else {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// Normalized prefix count with Winkler's constraint\n\t\t// (prefix length must be inferior or equal to 4)\n\t\tprefix = Min(prefix, 4)\n\n\t\t// Return calculated Jaro-Winkler similarity index\n\t\treturn jaroSim + 0.1*float32(prefix)*(1-jaroSim)\n\t}\n\n\treturn jaroSim\n}","func matchingIndex(str1 string, str2 string, distance int) float32 {\n\t// Convert strings to rune slices\n\truneStr1 := []rune(str1)\n\truneStr2 := []rune(str2)\n\t// Compare rune arrays length and make a matching percentage between them\n\tif len(runeStr1) \u003e= len(runeStr2) {\n\t\treturn float32(len(runeStr1)-distance) / float32(len(runeStr1))\n\t}\n\treturn float32(len(runeStr2)-distance) / float32(len(runeStr2))\n}","func DamerauLevenshteinDistance(str1, str2 string) int {\n\t// Convert string parameters to rune arrays to be compatible with non-ASCII\n\truneStr1 := []rune(str1)\n\truneStr2 := []rune(str2)\n\n\t// Get and store length of these strings\n\truneStr1len := len(runeStr1)\n\truneStr2len := len(runeStr2)\n\tif runeStr1len == 0 {\n\t\treturn runeStr2len\n\t} else if runeStr2len == 0 {\n\t\treturn runeStr1len\n\t} else if Equal(runeStr1, runeStr2) {\n\t\treturn 0\n\t}\n\n\t// Create alphabet based on input strings\n\tda := make(map[rune]int)\n\tfor i := 0; i \u003c runeStr1len; i++ {\n\t\tda[runeStr1[i]] = 0\n\t}\n\tfor i := 0; i \u003c runeStr2len; i++ {\n\t\tda[runeStr2[i]] = 0\n\t}\n\n\t// 2D Array for distance matrix : matrix[0..str1.length+2][0..s2.length+2]\n\tmatrix := make([][]int, runeStr1len+2)\n\tfor i := 0; i \u003c= runeStr1len+1; i++ {\n\t\tmatrix[i] = make([]int, runeStr2len+2)\n\t\tfor j := 0; j \u003c= runeStr2len+1; j++ {\n\t\t\tmatrix[i][j] = 0\n\t\t}\n\t}\n\n\t// Maximum possible distance\n\tmaxDist := runeStr1len + runeStr2len\n\n\t// Initialize matrix\n\tmatrix[0][0] = maxDist\n\tfor i := 0; i \u003c= runeStr1len; i++ {\n\t\tmatrix[i+1][0] = maxDist\n\t\tmatrix[i+1][1] = i\n\t}\n\tfor i := 0; i \u003c= runeStr2len; i++ {\n\t\tmatrix[0][i+1] = maxDist\n\t\tmatrix[1][i+1] = i\n\t}\n\n\t// Process edit distance\n\tvar cost int\n\tfor i := 1; i \u003c= runeStr1len; i++ {\n\t\tdb := 0\n\t\tfor j := 1; j \u003c= runeStr2len; j++ {\n\t\t\ti1 := da[runeStr2[j-1]]\n\t\t\tj1 := db\n\t\t\tif runeStr1[i-1] == runeStr2[j-1] {\n\t\t\t\tcost = 0\n\t\t\t\tdb = j\n\t\t\t} else {\n\t\t\t\tcost = 1\n\t\t\t}\n\n\t\t\tmatrix[i+1][j+1] = Min(\n\t\t\t\tMin(\n\t\t\t\t\tmatrix[i+1][j]+1,  // Addition\n\t\t\t\t\tmatrix[i][j+1]+1), // Deletion\n\t\t\t\tMin(\n\t\t\t\t\tmatrix[i][j]+cost, // Substitution\n\t\t\t\t\tmatrix[i1][j1]+(i-i1-1)+1+(j-j1-1))) // Transposition\n\t\t}\n\n\t\tda[runeStr1[i-1]] = i\n\t}\n\n\treturn matrix[runeStr1len+1][runeStr2len+1]\n}","func OSADamerauLevenshteinDistance(str1, str2 string) int {\n\t// Convert string parameters to rune arrays to be compatible with non-ASCII\n\truneStr1 := []rune(str1)\n\truneStr2 := []rune(str2)\n\n\t// Get and store length of these strings\n\truneStr1len := len(runeStr1)\n\truneStr2len := len(runeStr2)\n\tif runeStr1len == 0 {\n\t\treturn runeStr2len\n\t} else if runeStr2len == 0 {\n\t\treturn runeStr1len\n\t} else if Equal(runeStr1, runeStr2) {\n\t\treturn 0\n\t} else if runeStr1len \u003c runeStr2len {\n\t\treturn OSADamerauLevenshteinDistance(str2, str1)\n\t}\n\n\t// 2D Array\n\trow := Min(runeStr1len+1, 3)\n\tmatrix := make([][]int, row)\n\tfor i := 0; i \u003c row; i++ {\n\t\tmatrix[i] = make([]int, runeStr2len+1)\n\t\tmatrix[i][0] = i\n\t}\n\n\tfor j := 0; j \u003c= runeStr2len; j++ {\n\t\tmatrix[0][j] = j\n\t}\n\n\tvar count int\n\tfor i := 1; i \u003c= runeStr1len; i++ {\n\t\tmatrix[i%3][0] = i\n\t\tfor j := 1; j \u003c= runeStr2len; j++ {\n\t\t\tif runeStr1[i-1] == runeStr2[j-1] {\n\t\t\t\tcount = 0\n\t\t\t} else {\n\t\t\t\tcount = 1\n\t\t\t}\n\n\t\t\tmatrix[i%3][j] = Min(Min(matrix[(i-1)%3][j]+1, matrix[i%3][j-1]+1),\n\t\t\t\tmatrix[(i-1)%3][j-1]+count) // insertion, deletion, substitution\n\t\t\tif i \u003e 1 \u0026\u0026 j \u003e 1 \u0026\u0026 runeStr1[i-1] == runeStr2[j-2] \u0026\u0026 runeStr1[i-2] == runeStr2[j-1] {\n\t\t\t\tmatrix[i%3][j] = Min(matrix[i%3][j], matrix[(i-2)%3][j-2]+1) // translation\n\t\t\t}\n\t\t}\n\t}\n\treturn matrix[runeStr1len%3][runeStr2len]\n}","func HammingDistance(str1, str2 string) (int, error) {\n\t// Convert strings to rune array to handle no-ASCII characters\n\truneStr1 := []rune(str1)\n\truneStr2 := []rune(str2)\n\n\tif len(runeStr1) != len(runeStr2) {\n\t\treturn 0, errors.New(\"Undefined for strings of unequal length\")\n\t} else if Equal(runeStr1, runeStr2) {\n\t\treturn 0, nil\n\t}\n\n\tvar counter int\n\tfor i := 0; i \u003c len(runeStr1); i++ {\n\t\tif runeStr1[i] != runeStr2[i] {\n\t\t\tcounter++\n\t\t}\n\t}\n\n\treturn counter, nil\n}","func Shingle(s string, k int) map[string]int {\n\tm := make(map[string]int)\n\tif s != \"\" \u0026\u0026 k != 0 {\n\t\truneS := []rune(s)\n\n\t\tfor i := 0; i \u003c len(runeS)-k+1; i++ {\n\t\t\tm[string(runeS[i:i+k])]++\n\t\t}\n\t}\n\treturn m\n}","func SorensenDiceCoefficient(str1, str2 string, splitLength int) float32 {\n\tif str1 == \"\" \u0026\u0026 str2 == \"\" {\n\t\treturn 0\n\t}\n\tshingle1 := Shingle(str1, splitLength)\n\tshingle2 := Shingle(str2, splitLength)\n\n\tintersection := float32(0)\n\tfor i := range shingle1 {\n\t\tif _, ok := shingle2[i]; ok {\n\t\t\tintersection++\n\t\t}\n\t}\n\treturn 2.0 * intersection / float32(len(shingle1)+len(shingle2))\n}","func QgramDistanceCustomNgram(splittedStr1, splittedStr2 map[string]int) int {\n\tunion := make(map[string]int)\n\tfor i := range splittedStr1 {\n\t\tunion[i] = 0\n\t}\n\tfor i := range splittedStr2 {\n\t\tunion[i] = 0\n\t}\n\n\tres := 0\n\tfor i := range union {\n\t\tres += int(math.Abs(float64(splittedStr1[i] - splittedStr2[i])))\n\t}\n\n\treturn res\n}","func QgramSimilarity(str1, str2 string, splitLength int) float32 {\n\tsplittedStr1 := Shingle(str1, splitLength)\n\tsplittedStr2 := Shingle(str2, splitLength)\n\tres := float32(QgramDistanceCustomNgram(splittedStr1, splittedStr2))\n\treturn 1 - (res / float32(len(splittedStr1)+len(splittedStr2)))\n}","func StringsSimilarity(str1 string, str2 string, algo Algorithm) (float32, error) {\n\tswitch algo {\n\tcase Levenshtein:\n\t\treturn matchingIndex(str1, str2, LevenshteinDistance(str1, str2)), nil\n\tcase DamerauLevenshtein:\n\t\treturn matchingIndex(str1, str2, DamerauLevenshteinDistance(str1, str2)), nil\n\tcase OSADamerauLevenshtein:\n\t\treturn matchingIndex(str1, str2, OSADamerauLevenshteinDistance(str1, str2)), nil\n\tcase Lcs:\n\t\treturn matchingIndex(str1, str2, LCSEditDistance(str1, str2)), nil\n\tcase Hamming:\n\t\tdistance, err := HammingDistance(str1, str2)\n\t\tif err == nil {\n\t\t\treturn matchingIndex(str1, str2, distance), nil\n\t\t}\n\t\treturn 0.0, err\n\tcase Jaro:\n\t\treturn JaroSimilarity(str1, str2), nil\n\tcase JaroWinkler:\n\t\treturn JaroWinklerSimilarity(str1, str2), nil\n\tcase Cosine:\n\t\treturn CosineSimilarity(str1, str2, 2), nil\n\tcase Jaccard:\n\t\treturn JaccardSimilarity(str1, str2, 2), nil\n\tcase SorensenDice:\n\t\treturn SorensenDiceCoefficient(str1, str2, 2), nil\n\tcase Qgram:\n\t\treturn QgramSimilarity(str1, str2, 2), nil\n\tdefault:\n\t\treturn 0.0, errors.New(\"Illegal argument for algorithm method\")\n\t}\n}","func FuzzySearch(str string, strList []string, algo Algorithm) (string, error) {\n\tvar higherMatchPercent float32\n\tvar tmpStr string\n\tfor _, strToCmp := range strList {\n\t\tsim, err := StringsSimilarity(str, strToCmp, algo)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\tif sim == 1.0 {\n\t\t\treturn strToCmp, nil\n\t\t} else if sim \u003e higherMatchPercent {\n\t\t\thigherMatchPercent = sim\n\t\t\ttmpStr = strToCmp\n\t\t}\n\t}\n\n\treturn tmpStr, nil\n}"],"Enums":[]}

{"Includes":["import (\n)"],"Defines":["const (\n)"],"TypeDefs":[],"Globals":["var (\n)","var i int"],"Structs":[],"Function Declarations":["","",""],"Function Implementations":["func Min(a int, b int) int {\n\tif b \u003c a {\n\t\treturn b\n\t}\n\treturn a\n}","func Equal(a, b []rune) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i, v := range a {\n\t\tif v != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","func LevenshteinDistance(str1, str2 string) int {\n\t// Convert string parameters to rune arrays to be compatible with non-ASCII\n\truneStr1 := []rune(str1)\n\truneStr2 := []rune(str2)\n\n\t// Get and store length of these strings\n\truneStr1len := len(runeStr1)\n\truneStr2len := len(runeStr2)\n\tif runeStr1len == 0 {\n\t\treturn runeStr2len\n\t} else if runeStr2len == 0 {\n\t\treturn runeStr1len\n\t} else if Equal(runeStr1, runeStr2) {\n\t\treturn 0\n\t}\n\n\tcolumn := make([]int, runeStr1len+1)\n\n\tfor y := 1; y \u003c= runeStr1len; y++ {\n\t\tcolumn[y] = y\n\t}\n\tfor x := 1; x \u003c= runeStr2len; x++ {\n\t\tcolumn[0] = x\n\t\tlastkey := x - 1\n\t\tfor y := 1; y \u003c= runeStr1len; y++ {\n\t\t\toldkey := column[y]\n\t\t\tvar i int\n\t\t\tif runeStr1[y-1] != runeStr2[x-1] {\n\t\t\t\ti = 1\n\t\t\t}\n\t\t\tcolumn[y] = Min(\n\t\t\t\tMin(column[y]+1, // insert\n\t\t\t\t\tcolumn[y-1]+1), // delete\n\t\t\t\tlastkey+i) // substitution\n\t\t\tlastkey = oldkey\n\t\t}\n\t}\n\n\treturn column[runeStr1len]\n}"],"Enums":[]}

{"Includes":[],"Defines":["const ()"],"TypeDefs":["type StringHashMap map[string]struct{}"],"Globals":["var ()"],"Structs":[],"Function Declarations":["",""],"Function Implementations":["func (m StringHashMap) AddAll(srcMap StringHashMap) {\n\tfor key := range srcMap {\n\t\tm[key] = struct{}{}\n\t}\n}","func processLCSBacktrackAll(str1, str2 string, lcsMatrix [][]int, m, n int) StringHashMap {\n\t// Convert strings to rune array to handle no-ASCII characters\n\truneStr1 := []rune(str1)\n\truneStr2 := []rune(str2)\n\n\t// Map containing all commons substrings (Hash set builded from map)\n\tsubstrings := make(StringHashMap)\n\n\tif m == 0 || n == 0 {\n\t\tsubstrings[\"\"] = struct{}{}\n\t} else if runeStr1[m-1] == runeStr2[n-1] {\n\t\tfor key := range processLCSBacktrackAll(str1, str2, lcsMatrix, m-1, n-1) {\n\t\t\tsubstrings[key+string(runeStr1[m-1])] = struct{}{}\n\t\t}\n\t} else {\n\t\tif lcsMatrix[m-1][n] \u003e= lcsMatrix[m][n-1] {\n\t\t\tsubstrings.AddAll(processLCSBacktrackAll(str1, str2, lcsMatrix, m-1, n))\n\t\t}\n\t\tif lcsMatrix[m][n-1] \u003e= lcsMatrix[m-1][n] {\n\t\t\tsubstrings.AddAll(processLCSBacktrackAll(str1, str2, lcsMatrix, m, n-1))\n\t\t}\n\t}\n\n\treturn substrings\n}"],"Enums":[]}

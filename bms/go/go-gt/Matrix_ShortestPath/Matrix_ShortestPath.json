{"Includes":["import \"container/list\""],"Defines":["const ()"],"TypeDefs":[],"Globals":["var ()"],"Structs":["type Matrix struct {\n\tN int64\n\tA []int64\n}","type container_list_List struct {\n\t// sentinel list element, only \u0026root, root.prev, and root.next are used\n\t// current list length excluding (this) sentinel element\n}","type container_list_Element struct {\n\t// Next and previous pointers in the doubly-linked list of elements.\n\t// To simplify the implementation, internally a list l is implemented\n\t// as a ring, such that \u0026l.root is both the next element of the last\n\t// list element (l.Back()) and the previous element of the first list\n\t// element (l.Front()).\n\n\t// The list to which this element belongs.\n\n\t// The value stored with this element.\n\n}"],"Function Declarations":["",""],"Function Implementations":["func (m Matrix) Get(i int64, j int64) int64 {\n\treturn m.A[i*m.N+j]\n}","func (G *Matrix) ShortestPath(src, tar int64, N *Matrix) (p *list.List) {\n\tp = list.New()\n\tif G.Get(src, tar) == 0 {\n\t\treturn\n\t}\n\tnext := N.Get(src, tar)\n\tif next == 0 {\n\t\tp.PushBack(tar)\n\t} else {\n\t\tp.PushBackList(G.ShortestPath(src, next-1, N))\n\t\tp.PushBackList(G.ShortestPath(next-1, tar, N))\n\t}\n\treturn\n}"],"Enums":[]}

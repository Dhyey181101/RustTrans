{"Includes":["import (\n\t\"fmt\"\n\t\"math\"\n\t\"math/rand\"\n)"],"Defines":["const ()"],"TypeDefs":["type Vector []int64"],"Globals":["var (\n\tVerbose bool\n)","var i int64","var t0 float64 = float64(dmin + (dmax-dmin)/10.0)","var fail int64 = 0","var temp float64 = t0","var r int64 = 0","var s int64 = 1","var i, j int64","var (\n\t\tdmin, dmax int64\n\t)","var i int64"],"Structs":["type Matrix struct {\n\tN int64\n\tA []int64\n}"],"Function Declarations":["","","","","","","","","","",""],"Function Implementations":["func (p Vector) Swap(i int64, j int64) {\n\tx := p[i]\n\tp[i] = p[j]\n\tp[j] = x\n}","func max(a, b int64) int64 {\n\tif a \u003e b {\n\t\treturn a\n\t}\n\treturn b\n}","func (v Vector) Len() int64 {\n\treturn int64(len(v))\n}","func (m Matrix) Get(i int64, j int64) int64 {\n\treturn m.A[i*m.N+j]\n}","func delta(a *Matrix, b *Matrix, p Vector, r int64, s int64) (d int64) {\n\tvar i int64\n\td = int64((a.Get(r, r)-a.Get(s, s))*(b.Get(p[s], p[s])-b.Get(p[r], p[r])) +\n\t\t(a.Get(r, s)-a.Get(s, r))*(b.Get(p[s], p[r])-b.Get(p[r], p[s])))\n\tfor i = 0; i \u003c p.Len(); i++ {\n\t\tif i != r \u0026\u0026 i != s {\n\t\t\td += (a.Get(i, r)-a.Get(i, s))*(b.Get(p[i], p[s])-b.Get(p[i], p[r])) +\n\t\t\t\t(a.Get(r, i)-a.Get(s, i))*(b.Get(p[s], p[i])-b.Get(p[r], p[i]))\n\t\t}\n\t}\n\treturn d\n}","func min(a, b int64) int64 {\n\tif a \u003c b {\n\t\treturn a\n\t}\n\treturn b\n}","func (v Vector) Copy(w Vector) {\n\tfor i := 0; i \u003c len(v); i++ {\n\t\tv[i] = w[i]\n\t}\n}","func cost(a *Matrix, b *Matrix, p Vector) (c int64) {\n\tvar i, j int64\n\tc = 0\n\tfor i = 0; i \u003c p.Len(); i++ {\n\t\tfor j = 0; j \u003c p.Len(); j++ {\n\t\t\tc += a.Get(i, j) * b.Get(p[i], p[j])\n\t\t}\n\t}\n\treturn c\n}","func initQAP(a *Matrix, b *Matrix, w Vector, c int64) (int64, int64, int64) {\n\tvar (\n\t\tdmin, dmax int64\n\t)\n\tn := w.Len()\n\tfor i := 0; i \u003c 10000; i++ {\n\t\tr := rand.Int63n(n)\n\t\ts := rand.Int63n(n - 1)\n\t\tif s \u003e= r {\n\t\t\ts = s + 1\n\t\t}\n\t\td := delta(a, b, w, r, s)\n\t\tc += d\n\t\tdmin = min(dmin, d)\n\t\tdmax = max(dmax, d)\n\t\tw.Swap(r, s)\n\t}\n\treturn c, dmin, dmax\n}","func (v Vector) Print() {\n\tfor i := 0; i \u003c len(v); i++ {\n\t\tfmt.Printf(\"%d \", v[i])\n\t}\n\tfmt.Print(\"\\n\")\n}","func QAP_SolveSA(a *Matrix, b *Matrix, p Vector, m int64) int64 {\n\tvar i int64\n\tn := p.Len()\n\tw := make(Vector, n)\n\tw.Copy(p)\n\tcc := cost(a, b, p)\n\tc, dmin, dmax := initQAP(a, b, w, cc)\n\tvar t0 float64 = float64(dmin + (dmax-dmin)/10.0)\n\ttf := float64(dmin)\n\tbeta := (t0 - tf) / (float64(m) * t0 * tf)\n\tvar fail int64 = 0\n\ttries := n * (n - 1) / 2\n\ttfound := t0\n\tvar temp float64 = t0\n\tvar r int64 = 0\n\tvar s int64 = 1\n\n\t// SA iterations\n\tfor i = 0; i \u003c m; i++ {\n\t\ttemp /= (beta*temp + 1)\n\t\ts++\n\t\tif s \u003e= n {\n\t\t\tr++\n\t\t\tif r \u003e= n-1 {\n\t\t\t\tr = 0\n\t\t\t}\n\t\t\ts = r + 1\n\t\t}\n\t\td := delta(a, b, w, r, s)\n\t\tif (d \u003c 0) || (rand.Float64() \u003c math.Exp(-float64(d)/temp)) || (fail == tries) {\n\t\t\tc += d\n\t\t\tw.Swap(r, s)\n\t\t\tfail = 0\n\t\t} else {\n\t\t\tfail++\n\t\t}\n\t\tif fail == tries {\n\t\t\tbeta = 0\n\t\t\ttemp = tfound\n\t\t}\n\n\t\t// Best solution improved ?\n\t\tif c \u003c cc {\n\t\t\tcc = c\n\t\t\tp.Copy(w)\n\t\t\ttfound = temp\n\t\t\tif Verbose {\n\t\t\t\tfmt.Printf(\"iteration %d: cost=%d\\n\", i, cc)\n\t\t\t\tp.Print()\n\t\t\t}\n\t\t}\n\t}\n\treturn cc\n}"],"Enums":[]}

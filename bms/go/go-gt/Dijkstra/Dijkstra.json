{"Includes":["import (\n\t\"math\"\n)"],"Defines":["const ()"],"TypeDefs":[],"Globals":["var ()","var i int64","var j int64"],"Structs":["type Matrix struct {\n\tN int64\n\tA []int64\n}","type heap struct {\n\tN int64\n\tI []int64\n\tA []int64\n\tW []int64\n}"],"Function Declarations":["","","","","","","","",""],"Function Implementations":["func (h heap) swap(a, b int64) {\n\ti, j := h.I[a], h.I[b]\n\th.I[a], h.I[b] = h.I[b], h.I[a]\n\th.A[i], h.A[j] = b, a\n}","func (h heap) less(a, b int64) bool {\n\ti, j := h.I[a], h.I[b]\n\treturn h.W[i] \u003c h.W[j]\n}","func (h heap) up(j int64) {\n\tfor {\n\t\ti := (j - 1) / 2\n\t\tif i == j || h.less(i, j) {\n\t\t\tbreak\n\t\t}\n\t\th.swap(i, j)\n\t\tj = i\n\t}\n}","func (m Matrix) Get(i int64, j int64) int64 {\n\treturn m.A[i*m.N+j]\n}","func (h heap) update(p []int64, i int64, G *Matrix) {\n\tvar j int64\n\tfor j = 0; j \u003c G.N; j++ {\n\t\tif G.Get(i, j) \u003e 0 {\n\t\t\tif h.W[i]+G.Get(i, j) \u003c h.W[j] {\n\t\t\t\tp[j] = i + 1\n\t\t\t\th.W[j] = h.W[i] + G.Get(i, j)\n\t\t\t\th.up(h.A[j])\n\t\t\t}\n\t\t}\n\t}\n}","func (h heap) down(i int64) {\n\tfor {\n\t\tleft := 2*i + 1\n\t\tif left \u003e= h.N {\n\t\t\tbreak\n\t\t}\n\t\tj := left\n\t\tif right := left + 1; right \u003c h.N \u0026\u0026 !h.less(left, right) {\n\t\t\tj = right\n\t\t}\n\t\tif h.less(i, j) {\n\t\t\tbreak\n\t\t}\n\t\th.swap(i, j)\n\t\ti = j\n\t}\n}","func (h *heap) pop() (i int64) {\n\ti = h.I[0]\n\th.N--\n\th.swap(0, h.N)\n\th.down(0)\n\treturn i\n}","func newHeap(n int64) (h heap) {\n\th.N = n\n\th.I = make([]int64, n)\n\th.A = make([]int64, n)\n\th.W = make([]int64, n)\n\tvar i int64\n\tfor i = 0; i \u003c n; i++ {\n\t\th.I[i] = i\n\t\th.A[i] = i\n\t\th.W[i] = math.MaxInt64\n\t}\n\treturn h\n}","func Dijkstra(G *Matrix, i int64) (p []int64) {\n\tp = make([]int64, G.N)\n\th := newHeap(G.N)\n\th.W[i] = 0\n\th.swap(i, 0)\n\tfor h.N \u003e 0 {\n\t\ti = h.pop()\n\t\tif h.W[i] == math.MaxInt64 {\n\t\t\treturn p\n\t\t}\n\t\th.update(p, i, G)\n\t}\n\treturn p\n}"],"Enums":[]}

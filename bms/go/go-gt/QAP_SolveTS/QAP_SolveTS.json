{"Includes":["import (\n\t\"fmt\"\n\t\"math\"\n\t\"math/rand\"\n)"],"Defines":["const Inf int64 = math.MaxInt64"],"TypeDefs":["type Vector []int64"],"Globals":["var (\n\tVerbose bool\n)","var i, j, current_cost, iter int64","var i int64"],"Structs":["type Matrix struct {\n\tN int64\n\tA []int64\n}"],"Function Declarations":["","","","","","","","","","",""],"Function Implementations":["func NewMatrix(n int64) (m *Matrix) {\n\tm = new(Matrix)\n\tm.N = n\n\tm.A = make([]int64, n*n)\n\treturn m\n}","func (v Vector) Copy(w Vector) {\n\tfor i := 0; i \u003c len(v); i++ {\n\t\tv[i] = w[i]\n\t}\n}","func (m Matrix) Get(i int64, j int64) int64 {\n\treturn m.A[i*m.N+j]\n}","func delta_part(a, b, dist *Matrix, p Vector, i, j, r, s int64) int64 {\n\treturn (dist.Get(i, j) + (a.Get(r, i)-a.Get(r, j)+a.Get(s, j)-a.Get(s, i))*\n\t\t(b.Get(p[s], p[i])-b.Get(p[s], p[j])+b.Get(p[r], p[j])-b.Get(p[r], p[i])) +\n\t\t(a.Get(i, r)-a.Get(j, r)+a.Get(j, s)-a.Get(i, s))*\n\t\t\t(b.Get(p[i], p[s])-b.Get(p[j], p[s])+b.Get(p[j], p[r])-b.Get(p[i], p[r])))\n}","func (v Vector) Len() int64 {\n\treturn int64(len(v))\n}","func (m Matrix) Set(i int64, j int64, v int64) {\n\tm.A[i*m.N+j] = v\n}","func delta(a *Matrix, b *Matrix, p Vector, r int64, s int64) (d int64) {\n\tvar i int64\n\td = int64((a.Get(r, r)-a.Get(s, s))*(b.Get(p[s], p[s])-b.Get(p[r], p[r])) +\n\t\t(a.Get(r, s)-a.Get(s, r))*(b.Get(p[s], p[r])-b.Get(p[r], p[s])))\n\tfor i = 0; i \u003c p.Len(); i++ {\n\t\tif i != r \u0026\u0026 i != s {\n\t\t\td += (a.Get(i, r)-a.Get(i, s))*(b.Get(p[i], p[s])-b.Get(p[i], p[r])) +\n\t\t\t\t(a.Get(r, i)-a.Get(s, i))*(b.Get(p[s], p[i])-b.Get(p[r], p[i]))\n\t\t}\n\t}\n\treturn d\n}","func cube(x float64) float64 {\n\treturn x * x * x\n}","func (v Vector) Print() {\n\tfor i := 0; i \u003c len(v); i++ {\n\t\tfmt.Printf(\"%d \", v[i])\n\t}\n\tfmt.Print(\"\\n\")\n}","func (p Vector) Swap(i int64, j int64) {\n\tx := p[i]\n\tp[i] = p[j]\n\tp[j] = x\n}","func QAP_SolveTS(a, b *Matrix, p Vector, opt, tabu_duration, aspiration, nr_iterations int64) int64 {\n\tvar i, j, current_cost, iter int64\n\tbest_cost := Inf\n\tn := p.Len()\n\tdist := NewMatrix(n)\n\ttabu_list := NewMatrix(n)\n\tbest_sol := make(Vector, n)\n\tbest_sol.Copy(p)\n\tcurrent_cost = 0\n\tfor i = 0; i \u003c n; i++ {\n\t\tfor j = 0; j \u003c n; j++ {\n\t\t\tcurrent_cost += a.Get(i, j) * b.Get(p[i], p[j])\n\t\t\tif i \u003c j {\n\t\t\t\tdist.Set(i, j, delta(a, b, p, i, j))\n\t\t\t}\n\t\t}\n\t}\n\tbest_cost = current_cost\n\n\t// tabu list initialization\n\tfor i = 0; i \u003c n; i++ {\n\t\tfor j = 0; j \u003c n; j++ {\n\t\t\ttabu_list.Set(i, j, -(n*i + j))\n\t\t}\n\t}\n\n\t// tabu search loop\n\tfor iter = 0; iter \u003c nr_iterations \u0026\u0026 best_cost \u003e opt; iter++ {\n\t\t// find best move (i_retained, j_retained)\n\t\ti_retained := Inf // in case all moves are tabu\n\t\tj_retained := Inf\n\t\tmin_dist := Inf\n\t\talready_aspired := false\n\n\t\tfor i = 0; i \u003c n-1; i++ {\n\t\t\tfor j = i + 1; j \u003c n; j++ {\n\t\t\t\tautorized := (tabu_list.Get(i, p[j]) \u003c iter) ||\n\t\t\t\t\t(tabu_list.Get(j, p[i]) \u003c iter)\n\n\t\t\t\taspired :=\n\t\t\t\t\t(tabu_list.Get(i, p[j]) \u003c iter-aspiration) ||\n\t\t\t\t\t\t(tabu_list.Get(j, p[i]) \u003c iter-aspiration) ||\n\t\t\t\t\t\t(current_cost+dist.Get(i, j) \u003c best_cost)\n\n\t\t\t\tif (aspired \u0026\u0026 !already_aspired) || // first move aspired\n\t\t\t\t\t(aspired \u0026\u0026 already_aspired \u0026\u0026 // many move aspired\n\t\t\t\t\t\t(dist.Get(i, j) \u003c min_dist)) || // =\u003e take best one\n\t\t\t\t\t(!aspired \u0026\u0026 !already_aspired \u0026\u0026 // no move aspired yet\n\t\t\t\t\t\t(dist.Get(i, j) \u003c min_dist) \u0026\u0026 autorized) {\n\t\t\t\t\ti_retained = i\n\t\t\t\t\tj_retained = j\n\t\t\t\t\tmin_dist = dist.Get(i, j)\n\t\t\t\t\tif aspired {\n\t\t\t\t\t\talready_aspired = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif i_retained == Inf {\n\t\t\tfmt.Println(\"All moves are tabu!\") // to be improved\n\t\t} else { // transpose elements in pos. i_retained and j_retained\n\n\t\t\tp.Swap(i_retained, j_retained)\n\n\t\t\t// update solution value\n\t\t\tcurrent_cost += dist.Get(i_retained, j_retained)\n\t\t\t// forbid reverse move for a random number of iterations\n\t\t\tz := iter + int64(cube(rand.Float64()))*tabu_duration\n\t\t\ttabu_list.Set(i_retained, p[j_retained], z)\n\t\t\tz = iter + int64(cube(rand.Float64()))*tabu_duration\n\t\t\ttabu_list.Set(j_retained, p[i_retained], z)\n\n\t\t\t// best solution improved ?\n\t\t\tif current_cost \u003c best_cost {\n\t\t\t\tbest_cost = current_cost\n\t\t\t\tbest_sol.Copy(p)\n\t\t\t\tif Verbose {\n\t\t\t\t\tfmt.Printf(\"iteration %d: cost=%d\\n\", iter, best_cost)\n\t\t\t\t\tbest_sol.Print()\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// update matrix of the move costs\n\t\t\tfor i = 0; i \u003c n-1; i = i + 1 {\n\t\t\t\tfor j = i + 1; j \u003c n; j = j + 1 {\n\t\t\t\t\tif i != i_retained \u0026\u0026 i != j_retained \u0026\u0026\n\t\t\t\t\t\tj != i_retained \u0026\u0026 j != j_retained {\n\t\t\t\t\t\ty := delta_part(a, b, dist, p, i, j, i_retained, j_retained)\n\t\t\t\t\t\tdist.Set(i, j, y)\n\t\t\t\t\t} else {\n\t\t\t\t\t\ty := delta(a, b, p, i, j)\n\t\t\t\t\t\tdist.Set(i, j, y)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tp.Copy(best_sol)\n\treturn best_cost\n}"],"Enums":[]}

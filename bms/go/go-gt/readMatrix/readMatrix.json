{"Includes":["import (\n\t\"bufio\"\n\t\"strconv\"\n)"],"Defines":["const ()"],"TypeDefs":[],"Globals":["var ()","var i, j int64","var b byte = ' '","var err error"],"Structs":["type bufio_Reader struct {\n\n\t// reader provided by the client\n\t// buf read and write positions\n\n\t// last byte read for UnreadByte; -1 means invalid\n\t// size of last rune read for UnreadRune; -1 means invalid\n}","type Matrix struct {\n\tN int64\n\tA []int64\n}"],"Function Declarations":["","","","","","",""],"Function Implementations":["func end(s string) (i int64) {\n\tfor i = 0; i \u003c int64(len(s)); i++ {\n\t\tif s[i] == ' ' || s[i] == '\\t' || s[i] == '\\n' {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn 0\n}","func (m Matrix) Set(i int64, j int64, v int64) {\n\tm.A[i*m.N+j] = v\n}","func skip(rd *bufio.Reader) {\n\tvar b byte = ' '\n\tvar err error\n\tfor b == ' ' || b == '\\t' || b == '\\n' {\n\t\tb, err = rd.ReadByte()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\trd.UnreadByte()\n}","func wskip(s string) string {\n\tfor i := 0; i \u003c len(s); i++ {\n\t\tif s[i] != ' ' \u0026\u0026 s[i] != '\\t' {\n\t\t\treturn s[i:]\n\t\t}\n\t}\n\treturn \"\"\n}","func readUint(s string) (int64, int64) {\n\ti := end(s)\n\tx, _ := strconv.ParseInt(s[:i], 10, 64)\n\treturn int64(x), i\n}","func NewMatrix(n int64) (m *Matrix) {\n\tm = new(Matrix)\n\tm.N = n\n\tm.A = make([]int64, n*n)\n\treturn m\n}","func readMatrix(rd *bufio.Reader, n int64) *Matrix {\n\tM := NewMatrix(n)\n\tvar i, j int64\n\tfor i = 0; i \u003c n; i++ {\n\t\tskip(rd)\n\t\tline, _ := rd.ReadString('\\n')\n\t\tfor j = 0; j \u003c n; j++ {\n\t\t\tline = wskip(line)\n\t\t\tx, p := readUint(line)\n\t\t\tM.Set(j, i, x)\n\t\t\tif p == 0 {\n\t\t\t\tpanic(\"bad int\")\n\t\t\t}\n\t\t\tline = line[p:]\n\t\t}\n\t}\n\treturn M\n}"],"Enums":[]}

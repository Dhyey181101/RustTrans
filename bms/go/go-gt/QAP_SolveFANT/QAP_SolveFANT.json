{"Includes":["import (\n\t\"fmt\"\n\t\"math\"\n\t\"math/rand\"\n)"],"Defines":["const Inf int64 = math.MaxInt64"],"TypeDefs":["type Vector []int64"],"Globals":["var (\n\tVerbose bool\n)","var inc, i, c int64","var i, j int64","var i, j, k, target, sum int64","var i int64","var i, j int64","var i, j, nMov int64","var i int64","var i int64"],"Structs":["type Matrix struct {\n\tN int64\n\tA []int64\n}"],"Function Declarations":["","","","","","","","","","","","","","","",""],"Function Implementations":["func (v Vector) Print() {\n\tfor i := 0; i \u003c len(v); i++ {\n\t\tfmt.Printf(\"%d \", v[i])\n\t}\n\tfmt.Print(\"\\n\")\n}","func (m Matrix) Get(i int64, j int64) int64 {\n\treturn m.A[i*m.N+j]\n}","func (p Vector) Swap(i int64, j int64) {\n\tx := p[i]\n\tp[i] = p[j]\n\tp[j] = x\n}","func NewMatrix(n int64) (m *Matrix) {\n\tm = new(Matrix)\n\tm.N = n\n\tm.A = make([]int64, n*n)\n\treturn m\n}","func (v Vector) Len() int64 {\n\treturn int64(len(v))\n}","func (v Vector) Copy(w Vector) {\n\tfor i := 0; i \u003c len(v); i++ {\n\t\tv[i] = w[i]\n\t}\n}","func cost(a *Matrix, b *Matrix, p Vector) (c int64) {\n\tvar i, j int64\n\tc = 0\n\tfor i = 0; i \u003c p.Len(); i++ {\n\t\tfor j = 0; j \u003c p.Len(); j++ {\n\t\t\tc += a.Get(i, j) * b.Get(p[i], p[j])\n\t\t}\n\t}\n\treturn c\n}","func unif(low, high int64) int64 {\n\treturn low + int64(float64(high-low+1)*rand.Float64())\n}","func Perm(p Vector) {\n\tn := int64(len(p))\n\tvar i int64\n\tfor i = 0; i \u003c n; i++ {\n\t\tp[i] = int64(i)\n\t}\n\tfor i = 0; i \u003c n; i++ {\n\t\tp.Swap(i, i+rand.Int63n(n-i))\n\t}\n}","func genTrace(p Vector, trace *Matrix) {\n\tvar i, j, k, target, sum int64\n\tn := p.Len()\n\tnexti := make(Vector, n)\n\tnextj := make(Vector, n)\n\tsum_trace := make(Vector, n)\n\n\tPerm(nexti)\n\tPerm(nextj)\n\tfor i = 0; i \u003c n; i++ {\n\t\tfor j = 0; j \u003c n; j++ {\n\t\t\tsum_trace[i] += trace.Get(i, j)\n\t\t}\n\t}\n\n\tfor i = 0; i \u003c n; i++ {\n\t\ttarget = unif(0, sum_trace[nexti[i]]-1)\n\t\tj = i\n\t\tsum = trace.Get(nexti[i], nextj[j])\n\t\tfor sum \u003c target {\n\t\t\tj++\n\t\t\tsum += trace.Get(nexti[i], nextj[j])\n\t\t}\n\t\tp[nexti[i]] = nextj[j]\n\t\tfor k = i; k \u003c n; k++ {\n\t\t\tsum_trace[nexti[k]] -= trace.Get(nexti[k], nextj[j])\n\t\t}\n\t\tnextj.Swap(j, i)\n\t}\n}","func delta(a *Matrix, b *Matrix, p Vector, r int64, s int64) (d int64) {\n\tvar i int64\n\td = int64((a.Get(r, r)-a.Get(s, s))*(b.Get(p[s], p[s])-b.Get(p[r], p[r])) +\n\t\t(a.Get(r, s)-a.Get(s, r))*(b.Get(p[s], p[r])-b.Get(p[r], p[s])))\n\tfor i = 0; i \u003c p.Len(); i++ {\n\t\tif i != r \u0026\u0026 i != s {\n\t\t\td += (a.Get(i, r)-a.Get(i, s))*(b.Get(p[i], p[s])-b.Get(p[i], p[r])) +\n\t\t\t\t(a.Get(r, i)-a.Get(s, i))*(b.Get(p[s], p[i])-b.Get(p[r], p[i]))\n\t\t}\n\t}\n\treturn d\n}","func localSearch(a *Matrix, b *Matrix, p Vector, cost *int64) {\n\t// set of moves, numbered from 0 to index\n\tvar i, j, nMov int64\n\tn := p.Len()\n\tmove := make(Vector, n*(n-1)/2)\n\tnMov = 0\n\tfor i = 0; i \u003c n-1; i++ {\n\t\tfor j = i + 1; j \u003c n; j++ {\n\t\t\tmove[nMov] = n*i + j\n\t\t\tnMov++\n\t\t}\n\t}\n\timproved := true\n\tfor k := 0; k \u003c 2 \u0026\u0026 improved; k++ {\n\t\timproved = false\n\t\tfor i = 0; i \u003c nMov-1; i++ {\n\t\t\tmove.Swap(i, unif(i+1, nMov-1))\n\t\t}\n\t\tfor i = 0; i \u003c nMov; i++ {\n\t\t\tr := move[i] / n\n\t\t\ts := move[i] % n\n\t\t\td := delta(a, b, p, r, s)\n\t\t\tif d \u003c 0 {\n\t\t\t\t*cost += d\n\t\t\t\tp.Swap(r, s)\n\t\t\t\timproved = true\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}","func (m Matrix) Set(i int64, j int64, v int64) {\n\tm.A[i*m.N+j] = v\n}","func initTrace(n, inc int64, trace *Matrix) {\n\tvar i, j int64\n\tfor i = 0; i \u003c n; i++ {\n\t\tfor j = 0; j \u003c n; j++ {\n\t\t\ttrace.Set(i, j, inc)\n\t\t}\n\t}\n}","func updateTrace(n int64, p, best_p Vector, inc *int64, r int64, trace *Matrix) {\n\tvar i int64\n\tfor i = 0; i \u003c n \u0026\u0026 p[i] == best_p[i]; i++ { // skip\n\t}\n\tif i == n {\n\t\t(*inc)++\n\t\tinitTrace(n, *inc, trace)\n\t} else {\n\t\tfor i = 0; i \u003c n; i++ {\n\t\t\ttrace.Set(i, p[i], trace.Get(i, p[i])+*inc)\n\t\t\ttrace.Set(i, best_p[i], trace.Get(i, best_p[i])+r)\n\t\t}\n\t}\n}","func QAP_SolveFANT(a *Matrix, b *Matrix, p Vector, r, m int64) int64 {\n\tvar inc, i, c int64\n\tn := p.Len()\n\tw := make(Vector, n)\n\tw.Copy(p)\n\ttrace := NewMatrix(n)\n\tinc = 1\n\tinitTrace(n, inc, trace)\n\tcc := Inf\n\n\t// FANT iterations\n\tfor i = 0; i \u003c m; i++ {\n\t\t// Build a new solution\n\t\tgenTrace(w, trace)\n\t\tc = cost(a, b, w)\n\t\t// Improve solution with a local search\n\t\tlocalSearch(a, b, w, \u0026c)\n\t\t// Best solution improved ?\n\t\tif c \u003c cc {\n\t\t\tcc = c\n\t\t\tp.Copy(w)\n\t\t\tif Verbose {\n\t\t\t\tfmt.Printf(\"iteration %d: cost=%d\\n\", i, cc)\n\t\t\t\tp.Print()\n\t\t\t}\n\t\t\tinc = 1\n\t\t\tinitTrace(n, inc, trace)\n\t\t} else {\n\t\t\t// Memory update\n\t\t\tupdateTrace(n, w, p, \u0026inc, r, trace)\n\t\t}\n\t}\n\treturn cc\n}"],"Enums":[]}

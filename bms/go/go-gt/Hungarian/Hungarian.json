{"Includes":["import (\n\t\"math\"\n)"],"Defines":["const ()"],"TypeDefs":[],"Globals":["var ()","var i, j int64","var i int64","var i, j, wr, rd, r int64","var j int64","var i int64","var d int64 = math.MaxInt64"],"Structs":["type Matrix struct {\n\tN int64\n\tA []int64\n}","type Env struct {\n\tM, N   int64\n\tG      *Matrix\n\tT, S   []bool\n\tSlack  []int64\n\tSlackx []int64\n\tPrev   []int64\n\tXy, Yx []int64\n\tLx, Ly []int64\n}"],"Function Declarations":["","","","","","","","",""],"Function Implementations":["func min(a, b int64) int64 {\n\tif a \u003c b {\n\t\treturn a\n\t}\n\treturn b\n}","func (m Matrix) Get(i int64, j int64) int64 {\n\treturn m.A[i*m.N+j]\n}","func max(a, b int64) int64 {\n\tif a \u003e b {\n\t\treturn a\n\t}\n\treturn b\n}","func newEnv(n int64) *Env {\n\te := new(Env)\n\te.M = 0\n\te.N = n\n\te.T = make([]bool, n)\n\te.S = make([]bool, n)\n\te.Slack = make([]int64, n)\n\te.Slackx = make([]int64, n)\n\te.Prev = make([]int64, n)\n\te.Xy = make([]int64, n)\n\te.Yx = make([]int64, n)\n\te.Lx = make([]int64, n)\n\te.Ly = make([]int64, n)\n\tvar i int64\n\tfor i = 0; i \u003c n; i++ {\n\t\te.Xy[i] = -1\n\t\te.Yx[i] = -1\n\t}\n\treturn e\n}","func initH(g *Matrix) (e *Env) {\n\tvar i, j int64\n\te = newEnv(g.N)\n\te.G = g\n\te.N = g.N\n\tfor i = 0; i \u003c e.N; i++ {\n\t\tfor j = 0; j \u003c e.N; j++ {\n\t\t\te.Lx[i] = max(e.Lx[i], e.G.Get(i, j))\n\t\t}\n\t}\n\treturn e\n}","func (e *Env) update() {\n\tvar i int64\n\tvar d int64 = math.MaxInt64\n\tfor i = 0; i \u003c e.N; i++ {\n\t\tif !e.T[i] {\n\t\t\td = min(d, e.Slack[i])\n\t\t}\n\t}\n\tfor i = 0; i \u003c e.N; i++ {\n\t\tif e.S[i] {\n\t\t\te.Lx[i] -= d\n\t\t}\n\t}\n\tfor i = 0; i \u003c e.N; i++ {\n\t\tif e.T[i] {\n\t\t\te.Ly[i] += d\n\t\t}\n\t}\n\tfor i = 0; i \u003c e.N; i++ {\n\t\tif !e.T[i] {\n\t\t\te.Slack[i] -= d\n\t\t}\n\t}\n}","func (e *Env) add(i, p int64) {\n\tvar j int64\n\te.S[i] = true\n\te.Prev[i] = p\n\tfor j = 0; j \u003c e.N; j++ {\n\t\tif e.Lx[i]+e.Ly[i]-e.G.Get(i, j) \u003c e.Slack[i] {\n\t\t\te.Slack[i] = e.Lx[i] + e.Ly[i] - e.G.Get(i, j)\n\t\t\te.Slackx[i] = j\n\t\t}\n\t}\n}","func (e *Env) augment() {\n\tvar i, j, wr, rd, r int64\n\twr = 0\n\trd = 0\n\tq := make([]int64, e.N)\n\tif e.M == e.N {\n\t\treturn\n\t}\n\tfor i = 0; i \u003c e.N; i++ {\n\t\tif e.Xy[i] == -1 {\n\t\t\twr++\n\t\t\tq[wr] = i\n\t\t\tr = i\n\t\t\te.Prev[i] = -2\n\t\t\te.S[i] = true\n\t\t\tbreak\n\t\t}\n\t}\n\tfor i = 0; i \u003c e.N; i++ {\n\t\te.Slack[i] = e.Lx[r] + e.Ly[i] - e.G.Get(r, i)\n\t\te.Slackx[i] = r\n\t}\n\tfor {\n\t\tfor rd \u003c wr {\n\t\t\trd++\n\t\t\ti = q[rd]\n\t\t\tfor j = 0; j \u003c e.N; j++ {\n\t\t\t\tif e.G.Get(i, j) == e.Lx[i]+e.Ly[j] \u0026\u0026 !e.T[j] {\n\t\t\t\t\tif e.Yx[j] == -1 {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\te.T[j] = true\n\t\t\t\t\twr++\n\t\t\t\t\tq[wr] = e.Yx[j]\n\t\t\t\t\te.add(e.Yx[j], i)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif j \u003c e.N {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif j \u003c e.N {\n\t\t\tbreak\n\t\t}\n\t\te.update()\n\t\twr = 0\n\t\trd = 0\n\t\tfor j = 0; j \u003c e.N; j++ {\n\t\t\tif !e.T[j] \u0026\u0026 e.Slack[j] == 0 {\n\t\t\t\tif e.Yx[i] == -1 {\n\t\t\t\t\ti = e.Slackx[j]\n\t\t\t\t\tbreak\n\t\t\t\t} else {\n\t\t\t\t\te.T[j] = true\n\t\t\t\t\tif !e.S[e.Yx[j]] {\n\t\t\t\t\t\twr++\n\t\t\t\t\t\tq[wr] = e.Yx[j]\n\t\t\t\t\t\te.add(e.Yx[j], e.Slackx[j])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif j \u003c e.N {\n\t\t\treturn\n\t\t}\n\t}\n\tif j \u003c e.N {\n\t\te.M++\n\t\tfor i != -2 {\n\t\t\tk := e.Xy[i]\n\t\t\te.Yx[j] = i\n\t\t\te.Xy[i] = j\n\t\t\ti = e.Prev[i]\n\t\t\tj = k\n\t\t}\n\t\te.augment()\n\t}\n}","func Hungarian(g *Matrix) (xy []int64, yx []int64) {\n\te := initH(g)\n\te.augment()\n\treturn e.Xy, e.Yx\n}"],"Enums":[]}
